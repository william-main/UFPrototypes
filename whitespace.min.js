/*
* * *	* * *	* * *	* * *	* * *	* * *	* * *
 * *	 * *	 * *	 * *	 * *	 * *	 * *
Whitespace Scripts Collection - www.whitespacers.com
Copyright (c) Whitespace Scotland, Ltd 2009-2013. All rights reserved.
Please do not modify, make copies of or redistribute this file.
File generated on Tue, 19 Nov 2013 18:12:00 +0000
Scripts included: jquery.utils.js, ws-gat.js, jquery.ws-forms.js, jquery.ws-carousel.js
*/

//Sourced from: jquery.utils.js, updated: 29 October 2013 10:19 am
/*global unescape: false, escape: false, sessionStorage: false */
/**
* == Whitespace ==
**/

/** section: Whitespace
* WS
* The WS (Whitespace) namespace contains various utility classes and function which can be used
* to perform various tasks. Generic, huh?
*
* Most classes within this namespace do not need instancing, and can be used as static classes.
**/
window.WS=function(e){return e.fn.serializeObject||(e.fn.serializeObject=function(){var t,n={};return t=this.serializeArray(),e.each(t,function(){void 0!==n[this.name]?(n[this.name].push||(n[this.name]=[n[this.name]]),n[this.name].push(this.value||"")):n[this.name]=this.value||""}),n}),"undefined"==typeof e.fn.WS&&(e.fn.WS=function(){var t={},n={};return n.CreateClass=function(n,o){var i=0,r=[];t[n]=function(){var t,n=arguments,s="ws."+name+"-instance-index",a=this;return this.each(function(){var u=e(this);if(void 0===(t=u.data(s))&&(u.data(s,i),t=i,i+=1),"string"==typeof n[1]){if(!r[t]||!r[t][n[1]])throw new Error("Instance must be created before methods are used");a=r[t][n[1]].apply(this,Array.prototype.slice.call(n,2))}else r[t]||r.push(new o(this,Array.prototype.slice.call(n,1)))}),a}},function(e){return 3===arguments.length&&n[arguments[0]]?void n[arguments[0]].apply(this,Array.prototype.slice.call(arguments,1)):void 0!==e&&"function"==typeof t[e]?t[e].apply(this,arguments):this}}()),"undefined"==typeof Number.toFormatted&&(Number.prototype.toFormatted=function(e,t){var n,o,i,r,s;if(n=this.toString().split("."),e){if(i=n.length>1?n[1].substring(0,e):"0",r=i.length,e>r)for(s=0;e-r>s;s+=1)i+="0";n[1]="."+i}else n[1]="";if(t!==!1)for(o=/(\d+)(\d{3})/;o.test(n[0]);)n[0]=n[0].replace(o,"$1,$2");return n[0]+n[1]}),"undefined"!=typeof Element&&"undefined"==typeof document.documentElement.click&&document.createEvent&&(Element.prototype.click=function(e){var t;t=document.createEvent("MouseEvents"),t.initMouseEvent("click",!0,!0,window,0,0,0,0,0,!1,!1,!1,!1,0,null),e.dispatchEvent(t)}),"undefined"==typeof window.ob_set&&(window.ob_set=function(e,t){var n;for(n in t)t.hasOwnProperty(n)&&(null===t[n]||t[n].constructor!==Object||void 0!==e[n]&&e[n].constructor!==Object?void 0===e[n]&&(e[n]=t[n]):e[n]=window.ob_set(e[n]||{},t[n]));return e}),"undefined"==typeof Function.bind&&(Function.prototype.bind=function(e){var t=this;return function(){return t.apply(e,arguments)}}),{Include:function(){var t=[];return{load:function(n,o,i){var r;-1===e.inArray(n,t)?(i=i||"text/javascript",r=document.createElement("script"),r.setAttribute&&r.setAttribute("type",i),t.push(n),"function"==typeof o&&("onreadystatechange"in r?r.onreadystatechange=function(){("loaded"===this.readyState||"complete"===this.readyState)&&(this.onreadystatechange=null,o())}:r.onload=o),r.src=n,document.getElementsByTagName("head")[0].appendChild(r)):"function"==typeof o&&o()}}}(),JSMedia:function(){var t,n;return n={last_query:{query:null,string:""},run:function(n){var o,i,r,s,a;if(void 0===t.mqtest&&(t.mqtest=e("<span>",{id:"js-media-test"}).css({display:"none"})),this.last_query.query=n,"string"==typeof n)o=n;else if(n.length>0)for(o=[],r=0;r<n.length;r+=1){if(i=[],"string"==typeof n[r])i.push(n[r]);else for(s=0;s<n[r].length;s+=1)i.push(n[r][s]);o.push(i.join(" and "))}return"function"==typeof window.matchMedia?a=!!window.matchMedia(o).matches:(e(document.body).append(t.mqtest),o="only "+o.join(", "),e("head").append(t.mqcss=e("<style>",{type:"text/css",media:o})),t.mqcss[0].styleSheet?t.mqcss[0].styleSheet.cssText="#js-media-test { visibility: hidden; }":t.mqcss[0].sheet&&t.mqcss[0].sheet.insertRule("#js-media-test { visibility: hidden; }",0),a="hidden"===t.mqtest.css("visibility")?!0:!1,t.mqcss.remove(),t.mqtest.remove()),this.last_query.string=o,a},monitor:function(){var n,o,i;if(arguments.length<2)throw new Error("Arguments must include at least one query and a callback");for(o=[],n=0;n!==arguments.length;n+=1)"function"==typeof arguments[n]?i=arguments[n]:o.push(arguments[n]);return t.monitors.push({queries:o,callback:i}),t.exec_monitor(t.monitors.length-1,!0),1===t.monitors.length&&e(window).bind("resize",t.resize),t.monitors.length-1},end_monitor:function(n){var o;return t.monitors.length>n?(o=!!t.monitors.splice(n,1),0===t.monitors.length&&e(window).unbind("resize",t.resize),o):!1}},t={timers:{},monitors:[],resize:function(){t.timers.resize&&window.clearTimeout(t.timers.resize),t.timers.resize=window.setTimeout(function(){t.exec_monitor(),delete t.timers.resize}.bind(this),100)}.bind(n),exec_monitor:function(e,o){var i,r;if(o=o||!1,r=function(e){var i,r;for(r=[],i=0;i!==t.monitors[e].queries.length;i+=1)r.push(n.run(t.monitors[e].queries[i]));t.monitors[e].callback.apply(this,[r,o])},t.monitors.length>0)if(void 0===e)for(i=0;i!==t.monitors.length;i+=1)r(i);else r(e)}.bind(n)},n}(),Storage:function(){var t;return t={sets:{local:"undefined"!=typeof window.localStorage,session:"undefined"!=typeof window.sessionStorage,cookie:"undefined"!=typeof document.cookie},cookie:{getItem:function(e){return unescape(document.cookie.replace(new RegExp("(?:^|.*;\\s*)"+escape(e).replace(/[\-\.\+\*]/g,"\\$&")+"\\=((?:[^;](?!;))*[^;]?)(?:;.*)?|.*"),"$1"))||null},setItem:function(e,t,n,o){var i;i=escape(e)+"="+escape(t),"string"==typeof n&&(i+="; expires="+n),i+="; path="+(o||"/"),null!==WS.Storage.domain&&(i+="; domain="+WS.Storage.domain),document.cookie=i},removeItem:function(e){var n,o,i,r,s,a;if(e){for(i=[""],r=[""],a=location.hostname.split("."),s=location.pathname.replace(/^\/(.*?)\/$/,"$1").split("/"),n=a.length-2;n>=0;n-=1)i.push((n>0?".":"")+a.slice(n,a.length).join("."));for(n=0;n<=s.length;n+=1)r.push("/"+s.slice(0,n).join("/"));if(document.cookie=escape(e)+"=; expires=Thu, 01 Jan 1970 00:00:00 GMT;",null!==t.cookie.getItem(e))e:for(n=0;n<i.length;n+=1)for(o=0;o<r.length;o+=1)if(document.cookie=escape(e)+"=; expires=Thu, 01 Jan 1970 00:00:00 GMT;"+(""!==i[n]?" domain="+i[n]+";":"")+(""!==r[o]?" path="+r[o]:""),null===t.cookie.getItem(e))break e}}},log:function(e){"undefined"!=typeof console&&console.log&&console.log(e)}},{types:{Session:0,Local:1,Cookie:2},modes:{standard:0,basic:1},mode:0,domain:null,get:function(n,o,i){var r,s,a,u;if(void 0===o&&(o=null),void 0===i&&(i=WS.Storage.mode),r=null,t.sets.session&&(r=sessionStorage.getItem(n)),null===r&&t.sets.local&&(r=localStorage.getItem(n)),null===r&&(r=t.cookie.getItem(n)),i!==WS.Storage.modes.standard&&i!==WS.Storage.modes.basic)throw new Error("Invalid/undefined storage mode specified. Mode must be one of the WS.Storage.modes items.");if(null!==r&&i===WS.Storage.modes.standard)try{try{(r=e.parseJSON(r))&&"object"!=typeof r&&(r={val:r.toString()||null})}catch(c){r={val:r.toString()||null}}null!==r&&null!==r.val&&(r.expires?(a=new Date,u=new Date(r.expires),a>=u?(r=null,this.clear(n)):r=r.val):r=r.val)}catch(c){r=null}return s=null===r?o:r},set:function(e,n,o,i,r,s){var a,u;if(i=i||"/",!e)throw new Error("A valid key is required for setting a storage item.");if(n={val:n},void 0===s&&(s=WS.Storage.mode),void 0!==o&&null!==o){if(o.length&&o.length<=6?(o=[o[0]||0,isNaN(o[1])?0:o[1]-1,o[2]||1,o[3]||0,o[4]||0,o[5]||0,o[6]||0],u=new Date(o[0],o[1],o[2],o[3],o[4],o[5],o[6])):"string"==typeof o?u=new Date(o):o===!1&&(u=new Date,u.setTime(u.getTime()+31536e6)),!u.toUTCString)throw new Error("Expiry date "+o+" is in invalid format.");if((!t.sets.local||r===WS.Storage.types.Cookie)&&n.val.length>4e3)throw new Error("A maximum length of 4000 characters is allowed for using cookie-based storage.")}if(s===WS.Storage.modes.standard)if(void 0===u)try{t.sets.session&&r!==WS.Storage.types.Cookie?(a=WS.Storage.types.Session,sessionStorage.setItem(e,JSON.stringify(n))):(a=WS.Storage.types.Cookie,t.cookie.setItem(e,JSON.stringify(n)))}catch(c){t.log(c)}else if(t.sets.local&&r!==WS.Storage.types.Cookie){a=WS.Storage.types.Local;try{o!==!1?(n.expires=u.toUTCString(),localStorage.setItem(e,JSON.stringify(n))):localStorage.setItem(e,JSON.stringify(n))}catch(c){t.log(c)}}else a=WS.Storage.types.Cookie,t.cookie.setItem(e,JSON.stringify(n),u.toUTCString(),i);else{if(s!==WS.Storage.modes.basic)throw new Error("Invalid/undefined storage mode specified. Mode must be one of the WS.Storage.modes items.");if(void 0!==n.val&&(n.val=n.val.toString()||""),void 0===u)try{t.sets.session&&r!==WS.Storage.types.Cookie?(a=WS.Storage.types.Session,sessionStorage.setItem(e,n.val)):(a=WS.Storage.types.Cookie,t.cookie.setItem(e,n.val))}catch(c){t.log(c)}else if(t.sets.local&&r!==WS.Storage.types.Cookie)if(a=WS.Storage.types.Local,o!==!1)a=WS.Storage.types.Cookie,t.cookie.setItem(e,n.val,u.toUTCString(),i);else try{localStorage.setItem(e,n.val)}catch(c){t.log(c)}else a=WS.Storage.types.Cookie,t.cookie.setItem(e,n.val,u.toUTCString(),i)}return a},clear:function(e){t.sets.session&&sessionStorage.removeItem(e),t.sets.local&&localStorage.removeItem(e),t.sets.cookie&&t.cookie.removeItem(e)}}}()}}(window.jQuery),jQuery.easing.jswing=jQuery.easing.swing,jQuery.extend(jQuery.easing,{def:"easeOutQuad",swing:function(e,t,n,o,i){return jQuery.easing[jQuery.easing.def](e,t,n,o,i)},easeInQuad:function(e,t,n,o,i){return o*(t/=i)*t+n},easeOutQuad:function(e,t,n,o,i){return-o*(t/=i)*(t-2)+n},easeInOutQuad:function(e,t,n,o,i){return(t/=i/2)<1?o/2*t*t+n:-o/2*(--t*(t-2)-1)+n},easeInCubic:function(e,t,n,o,i){return o*(t/=i)*t*t+n},easeOutCubic:function(e,t,n,o,i){return o*((t=t/i-1)*t*t+1)+n},easeInOutCubic:function(e,t,n,o,i){return(t/=i/2)<1?o/2*t*t*t+n:o/2*((t-=2)*t*t+2)+n},easeInQuart:function(e,t,n,o,i){return o*(t/=i)*t*t*t+n},easeOutQuart:function(e,t,n,o,i){return-o*((t=t/i-1)*t*t*t-1)+n},easeInOutQuart:function(e,t,n,o,i){return(t/=i/2)<1?o/2*t*t*t*t+n:-o/2*((t-=2)*t*t*t-2)+n},easeInQuint:function(e,t,n,o,i){return o*(t/=i)*t*t*t*t+n},easeOutQuint:function(e,t,n,o,i){return o*((t=t/i-1)*t*t*t*t+1)+n},easeInOutQuint:function(e,t,n,o,i){return(t/=i/2)<1?o/2*t*t*t*t*t+n:o/2*((t-=2)*t*t*t*t+2)+n},easeInSine:function(e,t,n,o,i){return-o*Math.cos(t/i*(Math.PI/2))+o+n},easeOutSine:function(e,t,n,o,i){return o*Math.sin(t/i*(Math.PI/2))+n},easeInOutSine:function(e,t,n,o,i){return-o/2*(Math.cos(Math.PI*t/i)-1)+n},easeInExpo:function(e,t,n,o,i){return 0==t?n:o*Math.pow(2,10*(t/i-1))+n},easeOutExpo:function(e,t,n,o,i){return t==i?n+o:o*(-Math.pow(2,-10*t/i)+1)+n},easeInOutExpo:function(e,t,n,o,i){return 0==t?n:t==i?n+o:(t/=i/2)<1?o/2*Math.pow(2,10*(t-1))+n:o/2*(-Math.pow(2,-10*--t)+2)+n},easeInCirc:function(e,t,n,o,i){return-o*(Math.sqrt(1-(t/=i)*t)-1)+n},easeOutCirc:function(e,t,n,o,i){return o*Math.sqrt(1-(t=t/i-1)*t)+n},easeInOutCirc:function(e,t,n,o,i){return(t/=i/2)<1?-o/2*(Math.sqrt(1-t*t)-1)+n:o/2*(Math.sqrt(1-(t-=2)*t)+1)+n},easeInElastic:function(e,t,n,o,i){var r=1.70158,s=0,a=o;if(0==t)return n;if(1==(t/=i))return n+o;if(s||(s=.3*i),a<Math.abs(o)){a=o;var r=s/4}else var r=s/(2*Math.PI)*Math.asin(o/a);return-(a*Math.pow(2,10*(t-=1))*Math.sin(2*(t*i-r)*Math.PI/s))+n},easeOutElastic:function(e,t,n,o,i){var r=1.70158,s=0,a=o;if(0==t)return n;if(1==(t/=i))return n+o;if(s||(s=.3*i),a<Math.abs(o)){a=o;var r=s/4}else var r=s/(2*Math.PI)*Math.asin(o/a);return a*Math.pow(2,-10*t)*Math.sin(2*(t*i-r)*Math.PI/s)+o+n},easeInOutElastic:function(e,t,n,o,i){var r=1.70158,s=0,a=o;if(0==t)return n;if(2==(t/=i/2))return n+o;if(s||(s=.3*i*1.5),a<Math.abs(o)){a=o;var r=s/4}else var r=s/(2*Math.PI)*Math.asin(o/a);return 1>t?-.5*a*Math.pow(2,10*(t-=1))*Math.sin(2*(t*i-r)*Math.PI/s)+n:a*Math.pow(2,-10*(t-=1))*Math.sin(2*(t*i-r)*Math.PI/s)*.5+o+n},easeInBack:function(e,t,n,o,i,r){return void 0==r&&(r=1.70158),o*(t/=i)*t*((r+1)*t-r)+n},easeOutBack:function(e,t,n,o,i,r){return void 0==r&&(r=1.70158),o*((t=t/i-1)*t*((r+1)*t+r)+1)+n},easeInOutBack:function(e,t,n,o,i,r){return void 0==r&&(r=1.70158),(t/=i/2)<1?o/2*t*t*(((r*=1.525)+1)*t-r)+n:o/2*((t-=2)*t*(((r*=1.525)+1)*t+r)+2)+n},easeInBounce:function(e,t,n,o,i){return o-jQuery.easing.easeOutBounce(e,i-t,0,o,i)+n},easeOutBounce:function(e,t,n,o,i){return(t/=i)<1/2.75?7.5625*o*t*t+n:2/2.75>t?o*(7.5625*(t-=1.5/2.75)*t+.75)+n:2.5/2.75>t?o*(7.5625*(t-=2.25/2.75)*t+.9375)+n:o*(7.5625*(t-=2.625/2.75)*t+.984375)+n},easeInOutBounce:function(e,t,n,o,i){return i/2>t?.5*jQuery.easing.easeInBounce(e,2*t,0,o,i)+n:.5*jQuery.easing.easeOutBounce(e,2*t-i,0,o,i)+.5*o+n}});

//Sourced from: ws-gat.js, updated: 18 October 2013 11:05 am
/*global ob_set:true, _gaq:false, pageTracker:false */

/**
* == GAT ==
**/
var WSGat;

(function() {
	if (typeof Function.bind === "undefined") {
		Function.prototype.bind = function(scope) {
			var _function = this;

			return function() {
				return _function.apply(scope, arguments);
			};
		};
	}

	if (typeof Array.indexOf === "undefined") {
		Array.prototype.indexOf = function(test) {
			var a;

			for (a = 0; a < this.length; a += 1) {
				if (this[a] == test) {
					return a;
				}
			}

			return -1;
		};
	}

	if (typeof window.ob_set === "undefined") {
		window.ob_set = function(ob, defaults) {
			// set default object properties
			var key;

			for (key in defaults) {
				if (defaults.hasOwnProperty(key)) {
					if (defaults[key] !== null && defaults[key].constructor === Object &&
						(ob[key] === undefined || ob[key].constructor === Object)) {
						// traverse nested objects
						ob[key] = window.ob_set(ob[key] || {}, defaults[key]);
					} else if (ob[key] === undefined) {
						// replace missing objects
						ob[key] = defaults[key];
					}
				}
			}

			return ob;
		};
	}

	/** section: GAT
	* class WSGat
	*
	* The WSGat class is an extension/wrapper to the google analytics
	* `_gat` and `_gaq` tracking objects. When installed, provides a simple to use
	* and semi-automated tracking system for all Whitespace developed sites.
	*
	* The class can be instantiated by the following:
	*
	*     // assignment to a variable is optional, but helps for later use
	*     gat = WSGat({
	*         'account': 'UA-XXXXXXXX-X', // google UA ID (required for async)
	*         'hosts': [ // external sites to track by x-domain
	*             'www.myothersite.com'
	*         ]
	*     });
	*
	* On creation, WSGat will scan all of the existing links (`a` and `area`) and apply tracking
	* events accordingly. Links registered in this manner are called _passive_ links throughout
	* the documentation. An _active_ or _manual_ link is tracked by the host code using either the
	* [[WSGat#track]] or [[WSGat#track_event]] methods.
	*
	* #### Settings
	* Settings for customising how every instance of WSGat works can be defined.
	* These settings are defined by altering the [[WSGat.Settings]] object.
	*
	* #### Common options
	* These options are set on initialization, passed to [[WSGat]] and are
	* individual to each instance.
	*
	* * `async` (`Boolean`; default `true`): Tracking should use the 'new style'
	*   asynchronous tracking supplied by the `_gaq` object. See more below about the differences
	*   between the two tracking types.
	* * `account` (`String`): GA UA account number (provided by google) when using `async` tracking.
	* * `domain` (`String`; default `auto`): Domain tracking option. Either "auto", "none" or "`domain`"
	* * `ext_forward` (`Boolean`; default `true`): Setting this value to `true` will forward the
	*   User Agent whenever a passively parsed external link is clicked, set to `false` will
	*   disable forwarding. (See 'Gotchas' section).
	* * `hosts` (`Array`): An array of external hostnames, which when linked to, will be tracked using
	*   the cross-domain tracking functionality built into the search API.
	* * `initial_track` (`Boolean`): Set `true` to track initial page load. This option cannot be set
	*   for syncronous tracking.
	* * `vectors` (`Object`): Vector specific options.
	*   * `mailto` (`Object`): Mailto options.
	*        * `type` (`Number`: default `WSGat.Types.page`): One of the [[WSGat.Types]]
	*          options.
	*
	* #### Tracking types
	* There are two tracking types - _asynchronous_ and _synchronous_. Asynchronous tracking uses the
	* _gaq object supplied by the tracking API, and will log requests aysncronously from other requests
	* the browser may make. It has the added bonus of being completely built into WSGat, and not requiring
	* the google JS includes. An account number should be provided to the initialization class.
	*
	* Syncronous tracking is Google's older style of tracking (those familiar with _trackPageView) will
	* recognise it, and is more compatible with older sites. In this case, the google supplied script
	* snippets should be inserted into the page as normal, and WSGat will use the global _gat object to
	* extend tracking.
	*
	* #### Tracking 'gotchas'
	* In addition to tracking your links, both WSGat and the google analytics API may produce some
	* otherwise unexpected behaivour. Below are a few things to watch out for when implementing
	* tracking:
	*
	* ##### External links
	* External links are tracked by using two different methods. The reason for this is that when
	* clicking on an external link, the browser tends to want to make and complete an HTTP request for
	* that link, which can sometimes override the tracking request. Especially if sent synchronously.
	*
	* The first method is achieved by a timeout. When tracking passive external
	* link clicks, WSGat firstly stops the default action (to forward to the page), performs a track,
	* and then forwards on to the link after a timeout. The second method is to list the external domain
	* within `hosts`, which means the link is dealt with as a cross-domain link, controlled by the GA API.
	* The GA API tracks and manages forwarding to the external link internally.
	*
	* Both methods will forward onto the link - only if the link is being tracked passively. This means that
	* if the [[WSGat#track]] method is used, the link will be tracked, but forwarding must be handled
	* within your own code. Keep in mind that if you are creating external links that provide non-default
	* behaivour (such as opening in a new window), they should not be tracked passively, as WSGat will
	* forward on to the resulting URI automatically. This will have the unwanted effect of your original
	* event running as well as the document switching to the requested URI.
	*
	* See below for stopping passive tracking on links.
	*
	* ##### Document links
	* Links to documents (as validated by the regular expression in [[WSGat.Settings]]) are also forwarded
	* onto within WSGat. This is to ensure that the track completes before the document is requested.
	* If you have a document link that is not being tracked as such, or a link that is being mistakenly
	* read as a document, you should alter the regex parameters accordingly.
	*
	* ##### The `no-track` attribute
	* You can optionally apply a `rel` attribute to anchors and areas with the value containing `no-track`.
	* WSGat will ignore these links when creating passive tracking events. Of course, these links should
	* then be managed manually if you wish to track their requests. This can be done using the
	* [[WSGat#track]] and [[WSGat#track_event]] methods.
	*
	* ##### The `deregister` method
	* If WSGat has already been initialised and the link did not have the `no-track` relation, you can remove
	* links using the [[WSGat#deregister]] method. This will remove a link from the WSGat database and disable
	* tracking on it.
	**/
	window.WSGat = function(options) {
		/**
		* new WSGat([options])
		* - options (Object): Configuration options. Available options are listed in the [[WSGat]] class.
		*
		**/
		var cls, my;

		// create class & instance
		cls = {
			options: (options || {}),
			active: false,
			async: false,

			register: function() {
				return my.register.apply(this, arguments);
			},

			deregister: function() {
				return my.deregister.apply(this, arguments);
			},

			track: function() {
				return my.track.apply(this, arguments);
			},

			track_event: function() {
				return my.track_event.apply(this, arguments);
			},

			track_social: function() {
				return my.track_social.apply(this, arguments);
			}
		};

		// create private methods
		my = {
			settings: WSGat.Settings,

			enable: function() {
				// enables the class (after initialization)
				var links, i, href, rel, a;

				this.options = ob_set(this.options, {
					'async': true,
					'vectors': {
						'mailto': {
							'type': WSGat.Types.page
						}
					},
					'initial_track': true,
					'ext_forward': true
				});

				if (this.options.hosts === undefined) {
					this.options.hosts = [];
				}

				if (this.options.async) {
					// new style asynchronous tracking
					window._gaq = window._gaq || [];

					if (typeof this.options.account === "string" && this.options.account !== "") {
						_gaq.push(['_setAccount', this.options.account]);
					} else {
						throw "Invalid/undefined google account number supplied";
					}

					if (this.options.domain) {
						_gaq.push(['_setDomainName', this.options.domain]);
					}

					if (this.options.initial_track) {
						_gaq.push(['_trackPageview']);

						my.log("Tracking initial page: '" + location.href + "' (async)");
					}

					(function() {
						var ga, s;

						ga = document.createElement("script");

						ga.type = "text/javascript";
						ga.async = true;
						ga.src = (document.location.protocol == "https:" ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";

						s = document.getElementsByTagName("script")[0];
						s.parentNode.insertBefore(ga, s);
					}());

					this.async = true;

					if (this.options.hosts.length > 0) {
						_gaq.push(['_setAllowLinker', true]);
					}
				} else if (typeof window._gat === "object") {
					// old style synchronous tracking (requires script in page)
					this.async = false;

					if (this.options.domain) {
						pageTracker._setAllowLinker(this.options.domain);
					}

					if (this.options.hosts.length > 0) {
						pageTracker._setAllowLinker(true);
					}
				} else {
					throw "Neither async was requested nor pageTracker object could be found.";
				}

				my.observe(document, "click", my.event_handle);

				my.log("Extended tracking initialized (async " + (this.async ? "enabled" : "disabled") + ")");

				// create database
				my.registry = [];

				// scan document for links
				links = document.getElementsByTagName("a");

				for (i = 0; i < links.length; i += 1) {
					a = links[i];

					if (a.getAttribute) {
						href = a.getAttribute("href");
						rel = a.getAttribute("rel");
					} else {
						href = a.readAttribute("href");
						rel = a.readAttribute("rel");
					}

					if (href !== null && (href.indexOf("#") !== 0 && (rel === null || !rel.match(/no-track/)))) {
						switch (a.protocol) {
							case "mailto:":
								// register mailto
								if (this.options.vectors.mailto.type === WSGat.Types.page) {
									// track as a pageview
									this.register(a, WSGat.Types.page, {
										'uri': href,
										'track_uri': '/mailto/' + href.substring(7)
									});
								} else if (this.options.vectors.mailto.type === WSGat.Types.event) {
									// track as an event
									this.register(a, WSGat.Types.event, {
										'category': 'mailto',
										'action': href.substring(7)
									});
								}
								break;

							case "http:":
							case "https:":
							case "ftp:":
								// register http/ftp links
								if (href.match(my.settings.doc_re)) {
									// track documents
									this.register(a, WSGat.Types.Page, {
										'uri': href,
										'track_uri': '/downloads/' + href
									});
								} else if (my.test_uri(href).external) {
									// track external links
									this.register(a, WSGat.Types.Page, {
										'uri': href
									});
								}

								break;
						}
					}
				}

				this.active = true;
			}.bind(cls),

			/**
			* WSGat#register(elements[, type = WSGat.Types.page][, data][,event = 'click']) -> undefined
			* - elements (Element | Array): The element or array of elements to register a track event to.
			* - type (Number): One of the [[WSGat.Types]] types of tracking methods.
			* - data (Object): `type` specific data to register. (See below).
			*
			* Registers the `click` event type to the passed element(s). When this event is
			* fired, a single track will take place. In the case of `page` tracking, all arguments
			* except for `elements` are optional, although if you wish to customise the URI that is
			* tracked, an additional `data` hash should be specified.
			*
			* If an element is already in the registry, it will be removed before being inserted.
			*
			* At the moment, the `click` event is the only event supported.
			*
			* See [[WSGat#deregister]] for de-registration of elements.
			*
			* ### Type specific data
			* Depending on the type (currently `page` or `event`), the `data` argument can
			* be a hash with the following key/value pairs:
			*
			* #### For `page`:
			* * [`uri`] (String): The fully qualified URI to track. Can be either an internal or
			*   external URI.
			*
			* #### For `event`:
			* * `category` (String): The event category,
			* * `action` (String): The event action.
			* * [`label`] (String): The event label.
			* * [`value`] (Number): A value associated with the event label.
			*
			* See the [google API](http://code.google.com/apis/analytics/docs/gaJS/gaJSApiEventTracking.html)
			* for more information on event tracking.
			**/
			register: function(elements, type, data, event) {
				var a, b, element, href, element_string;

				type = type || WSGat.Types.page;
				event = event || "click";
				data = data || {};

				if (typeof elements !== "object" || !elements.length) {
					elements = [elements];
				}

				for (a = 0; a < elements.length; a += 1) {
					// loop through and register element(s)
					element = elements[a];

					// check the element isn't already registered
					for (b = 0; b != my.registry.length; b += 1) {
						if (my.registry[b].element === element) {
							my.registry.splice(b, 1);

							element_string = element.tagName;

							if (typeof element.id === "string") {
								element_string += "#" + element.id;
							}

							if (element.className !== "") {
								element_string += "." + element.className;
							}

							my.log("Element " + element_string + " is already registered - removing from registry.");
							break;
						}
					}

					try {
						if (element.tagName === "A" || element.tagName === "AREA") {
							if (element.getAttribute) {
								href = element.getAttribute("href");
							} else {
								href = element.readAttribute("href");
							}

							data = ob_set(data, {
								'uri': href
							});
						}
					} catch(e) {
						throw "Invalid/undefined element passed";
					}

					if (type === WSGat.Types.page) {
						if (data.uri !== undefined) {
							my.registry.push({
								'element': element,
								'event': event,
								'type': type,
								'data': data
							});
						} else {
							throw "Invalid data for page tracking registration supplied." +
								" A minimum of 'uri' must be included in the data object for non link elements.";
						}
					} else if (type === WSGat.Types.event) {
						if (data.category !== undefined && data.action !== undefined) {
							my.registry.push({
								'element': element,
								'event': event,
								'type': type,
								'data': data
							});
						} else {
							throw "Invalid data for event tracking registration supplied." +
								" A minimum of 'category' and 'action' must be included in the data object.";
						}
					}
				}
			},

			/**
			* WSGat#deregister(element) -> boolean
			* - element (Element): The element to deregister.
			*
			* Removes the specified `element` from the internal element registry. The element will
			* no longer be tracked when the appropriate event is fired upon it.
			*
			* Returns `true` if the element was successfully found and deregistered, `false` otherwise.
			*
			* ### Tracking unregistered elements
			*
			* It should go without saying that once deregistering an element, it will not be tracked.
			* You can track the element manually using the [[WSGat#track]] or [[WSGat#track_event]] methods.
			*
			* See [[WSGat#register]] for registration of elements.
			*
			* See the [google API](http://code.google.com/apis/analytics/docs/gaJS/gaJSApiEventTracking.html)
			* for more information on event tracking.
			**/
			deregister: function(element) {
				var a, element_string;

				for (a = 0; a != my.registry.length; a += 1) {
					if (my.registry[a].element === element) {
						my.registry.splice(a, 1);

						element_string = element.tagName;

						if (typeof element.id === "string") {
							element_string += "#" + element.id;
						}

						if (element.className !== "") {
							element_string += "." + element.className;
						}

						my.log("Element " + element_string + " removed from registry.");
						return true;
					}
				}

				return false;
			},

			event_handle: function(event) {
				var a, element, register;

				event = event || window.event();

				if (event && event.type === "click") {
					// obtain element from event
					element = event.srcElement || event.target;

					// search for element in the registry
					while (element) {
						for (a = 0; a != my.registry.length; a += 1) {
							if (my.registry[a].element === element) {
								register = my.registry[a];
								break;
							}
						}

						if (register) {
							break;
						}

						element = element.parentNode;
					}

					// act upon data (ooh!)
					if (register) {
						switch (register.type) {
							case WSGat.Types.page:
								return this.track(register.data.uri, register.data.track_uri, event);

							case WSGat.Types.event:
								return this.track_event(
									register.data.category,
									register.data.action,
									(register.data.label ? register.data.label : undefined),
									(register.data.value ? register.data.value : undefined),
									Boolean(register.data.runonce)
								);
						}
					}
				}
			}.bind(cls),

			/**
			* WSGat#track(uri[, track_uri = uri][, event]) -> Boolean | undefined
			* - uri (String): The URI to track and forward onto in the case of external URIs.
			* - track_uri (String): Overrides `uri` in for tracking when an external URI
			* is specified. WSGat will still forward on to the URI specified in `uri`.
			* - event (Event): When an Event object is specified, the link's default action will be
			* stopped for external links & document links, and forwarding will be performed either
			* by cross-domain linking or after a timeout.
			*
			* Returns `true` on successful track (when run manually), `false` when triggered by an
			* event (regardless of track status) and `undefined` when called before WSGat is fully active.
			*
			* Note: The cross domain link tracking will automatically forward to the tracked URI regardless
			* of any WSGat settings. Do not use this if you wish to execute other code or remain on the page
			* after tracking.
			**/
			track: function(uri, track_uri, event) {
				var test, redirect;

				if (!this.active) {
					return;
				}

				if (typeof track_uri !== "string" || track_uri === "") {
					track_uri = uri;
				}

				test = my.test_uri(uri);

				redirect = function() {
					window.setTimeout(function() {
						location.href = uri;
					}.bind(this), my.settings.transfer_timeout);
				};

				my.log(
					"Tracking" +
					(test.external ? " external" : "") + " page: '" + track_uri + "'" +
					(this.async ? " (async)" : "")
				);

				if (test.external) {
					// external links
					if (event !== undefined && this.options.ext_forward) {
						// event is specified - cancel default action
						if (event.preventDefault) {
							event.preventDefault();
						}
					}

					if (test.hostname && this.options.hosts.indexOf(test.hostname) !== -1) {
						/*cross-domain linker must use the original URI for tracking as it forwards
						within the tracking code*/
						if (this.async) {
							_gaq.push(['_setDomainName', my.settings.domain]);
							_gaq.push(['_link', uri]);
						} else {
							pageTracker._setDomainName(my.settings.domain);
							pageTracker._link(uri);
						}
					} else {
						// standard external link (forwards after a timeout)
						if (this.async) {
							_gaq.push(['_trackPageview', '/external/' + track_uri]);
						} else {
							pageTracker._trackPageview('/external/' + track_uri);
						}

						if (event !== undefined && this.options.ext_forward) {
							redirect();
						}
					}
				} else {
					// internal link
					if (test.document && event !== undefined) {
						// document link from a registered event
						if (event.preventDefault) {
							event.preventDefault();
						}
					}

					if (this.async) {
						_gaq.push(['_trackPageview', track_uri]);

						if (test.document && event !== undefined) {
							redirect();
						}
					} else {
						pageTracker._trackPageview(track_uri);

						if (test.document && event !== undefined) {
							// link is to a valid document
							redirect();
						}
					}
				}

				if (test.external || test.document) {
					// return false for registered event tracks
					return (event === undefined);
				} else {
					// return true - default event action continues
					return true;
				}
			},

			/**
			* WSGat#track_event(category, action[, label][, value = 0][, runonce]) -> Boolean
			* - category (String): Event category.
			* - action (String): Event action (such as 'play' for a video).
			* - label (String): An optional label for the event.
			*
			* Returns `true` on success, `false` on failure, or when called before `WSGat` is active.
			**/
			track_event: function(category, action, label, value, runonce) {
				// track an event
				var identifier, tracked;

				identifier = category+"/"+action+"["+label+"]";
				tracked = false;

				if (!this.active || (runonce && WSGat.Tracked.indexOf(identifier) !== -1)) {
					return false;
				}

				if (label !== undefined && label !== null) {
					my.log("Tracking event: " + category + ", " + action + " (" + label + ": '" + value + "')");

					if (!isNaN(value) && value !== null) {
						value = parseInt(value, 10);
					} else {
						value = 0;
					}

					if (this.async) {
						tracked = (_gaq.push(['_trackEvent', category, action, label, value]) === 0);
					} else {
						tracked = pageTracker._trackEvent(category, action, label, value);
					}
				} else {
					my.log("Tracking event: " + category + ", " + action);

					if (this.async) {
						tracked = (_gaq.push(['_trackEvent', category, action]) === 0);
					} else {
						tracked = pageTracker._trackEvent(category, action);
					}
				}

				WSGat.Tracked.push(identifier);

				return tracked;
			},

			/**
			* WSGat#track_social(network, action[, target][, path]) -> Undefined
			* - network (String): Network name (e.g. 'Facebook', 'Twitter' etc)
			* - action (string): Social action (e.g. 'Like', 'Share' etc)
			* - target (String): Social target URI or descriptor
			* - path (String): Page path (will default to location+search)
			*
			* Tracks a social event. using the _trackSocial method.
			*
			* More information can be found on the [google API](http://code.google.com/apis/analytics/docs/tracking/gaTrackingSocial.html).
			**/
			track_social: function(network, action, target, path) {
				my.log("Tracking social action: " + network + ", " + action + " [target: '" + target + "', path: '" + path + "']");

				if (this.async) {
					_gaq.push(['_trackSocial', network, action, target, path]);
				} else {
					pageTracker._trackSocial(network, action, target, path);
				}
			},

			test_uri: function(uri) {
				var result, hostname;

				result = {
					'external': false,
					'document': false
				};

				hostname = null;

				if (uri !== undefined) {
					hostname = uri.match(/:\/\/([^\/]*)/);

					// test for external URI
					if (hostname !== null &&
						(hostname[1].length > 3 && hostname[1] !== location.hostname && hostname[1] !== "")) {
						result.external = true;
					}

					// test for document link
					if (uri.match(my.settings.doc_re)) {
						result.document = true;
					}
				}

				result.hostname = (hostname !== null ? hostname[1] : null);

				return result;
			}.bind(cls),

			log: function() {
				// log event to the console (if active)
				var a;

				if (typeof console !== "undefined") {
					for (a = 0; a != arguments.length; a += 1) {
						console.log(arguments[a]);
					}
				}
			}.bind(cls),

			observe: function(element, event, fn) {
				if (element.addEventListener) {
					element.addEventListener(event, fn, false);
				} else if (element.attachEvent) {
					element.attachEvent("on" + event, fn);
				}
			}
		};

		// run post-initialization method
		my.enable();

		return cls;
	};

	/**
	* WSGat.Types
	* The main tracking types. Controls how automated link parsing and custom
	* vector parsing works. The various types are:
	*
	* * `page` (0): Track click event as a pageview.
	* * `event` (1) Track click event as an event.
	**/
	WSGat.Types = {
		// track types
		'page': 0,
		'event': 1
	};

	/**
	* WSGat.Settings
	* Klass settings which can be altered for all instances, should multiple
	* instances of this class be required. Settings are:
	*
	* * `doc_re` (RegExp): A regular expression object for parsing document extensions.
	*   If you wish to customise how WSGat parses a link as a document, enter your own
	*   RegExp object here.
	* * `transfer_timeout` (Number; default 100): In milliseconds, the time to wait before
	*   forwarding onto external links when traditional external forwarding is used.
	* * `domain` (String; default 'none'): The cookie domain for tracking
	**/
	WSGat.Settings = {
		// settings (for all instances)
		'doc_re': /\.(?:doc|eps|jpg|png|svg|xls|ppt|pdf|xls|zip|txt|vsd|vxd|js|css|rar|exe|wma|mov|avi|wmv|mp3)($|\&|\?)/i,
		'transfer_timeout': 100,
		'domain': 'none'
	};

	WSGat.Tracked = [];
}());

//Sourced from: jquery.ws-forms.js, updated: 24 October 2013 12:32 pm
/*global ob_set: false */
/**
* == WSForm ==
**/

/** section: WSForm
* class WSForm
*
* This class provides functional handling, error checking and display support for all forms within
* your website.
*
* #### Initialization process
* Every form passed to `WSForm` is parsed and, depending on options, altered in various ways. Once
* the class is instantiated with the following (for example)...
*
*     var handler = WSForm($("myform"), {
*         myfield': true
*     });
*
* The following takes place:
*
* 1. Every field is collected and added to an internal hash. It is on this hash that `WSForm`
* works. Any new fields added after initialization will not be managed, unless they are passed to the
* [[WSForm#add_field]] method.
* 2. 'Placeholder' fields are located and altered to remove their labels. Labels are found by locating
* another element within the placeholder's label with the appropriate class name.
* 3. A popup element is added to the form and the form then has its `position` CSS attribute set to
* `relative` unless it is already `absolute`.
* 4. A 'submit' button is located. This is usually an `input` with a type of `submit` or `image`.
* the first submit button found will be considered to be the form's master button.
* 5. Lastly, if `options.tabs` is set to true, all of the `fieldset`s - except for the `fieldset` with
* the appropriate class - are parsed into a tabbed form structure, and used to generate a tab list.
*
* #### Placeholder fields
* Fields given the `placeholder` class (see `new` for classnames) will be registered as placeholder fields,
* and thusly, their label text element (defined below) will be removed and instead, the value of their
* `title` attribute will display when the `focus` event is triggered on the field. Collective (radio/checkbox)
* fields cannot be set as placeholder fields and will trigger an error when attempted.
*
* If a field without a `title` attribute is attempted to be registered as a placeholder, an error will appear
* in the logging window if one is enabled. The field will then be skipped.
*
* #### Events fired
* The following events will be fired during the form's handling. They can be observed by external JavaScript.
*
* ##### `form:submitting`
* Fired before the form is submitted. This event does not fire if `halt` is disabled.
*
* ###### Passed arguments
* 1. `event` (`Object`): The standard event object.
* 2. `method` (`String`): One of the [[WSForm.SubmitMethods]] methods. This may not be the method of the
*    form as predetermined by the HTML, but could be redefined by the initialization options.
*
* ##### `form:submitted`
* Fired on the managed form when an AJAX type submission has completed.
* Arguments are as the usual 'success' response (see: http://api.jquery.com/jQuery.ajax/)
*
* ###### Passed arguments
* 1. `event` (`Object`): The standard event object.
* 2. `data` (`String`): The response data.
* 3. `status` (`String`): The response status.
* 4. `jqXHR` (`Object`): The jQuery XHR implementation.
*
* ##### `form:error`
* Fired on the managed form when a validation error has occured.
*
* ###### Passed arguments
* 1. `form` (`Object`): The (jQuery extended) original form element.
* 2. `faults` (`Array`): The faults array containing indexes errors relating to each faulty field.
*
**/
(function($, ob_set) {
	var WSForm;

	// require WS utility namespace
	if (typeof WS === "undefined") {
		throw new Error("Whitespace utility namespace does not exist");
	}

	/** section: WSForm
	* class jQuery
	**/

	$.fn.extend({
		/**
		* jQuery#formOffset() -> Mixed
		*
		* Retrieves the element's position offset from the form.
		*
		* Returns an Object of offsets containing `left` and `top` properties, or `false` if
		* the element could not be retrieved.
		**/
		formOffset: function() {
			// data the offset from element to the form
			var element, el_pos, pos;

			pos = [];

			if (!(element = $(this))) {
				// element can't be retrieved - return false
				return false;
			}

			if (element[0].tagName === "FORM") {
				// element is the form - return base offset
				return {
					'left': 0,
					'top': 0
				};
			}

			pos = element.position();

			while ((element = element.offsetParent()).length > 0) {
				if (element[0].tagName === "FORM" || element[0].tagName === "HTML") {
					// break if form tag (or for some reason the HTML tag) is found
					break;
				}

				el_pos = element.position();

				pos.left = pos.left + el_pos.left;
				pos.top = pos.top + el_pos.top;
			}

			return pos;
		}
	});

	WSForm = function(form, options, fields) {
		/**
		* new WSForm(form[, options][, fields])
		* - form (Object): HTML Form element. Ideally, the form should have an ID or name.
		* if neither can be supplied, the `fields` argument can be used to define field requirements.
		* - options (Object): An optional hash of instance-specific options. (See below).
		* - fields (Object): An optional hash of field/options pairs. Will augment any existing fields
		* set for this form. See [[WSForm.Fields]] for more information.
		*
		*
		* #### Options
		* The `options` argument is defined as a key/value hash. The available options are as follows:
		*
		* * `halt` (`Boolean`; default `true`): Set `true` to halt form submission before checking validity.
		*   When set to `false`, will only stop submission when the form is known to contain invalid elements.
		* * `popup` (`Object`): Default options for the popup dialog:
		*    * `type` (`Number`; default `WSForm.MsgTypes.Message`): Type of dialog box.
		*    * `alignment` (`Number`; default `WSForm.Alignments.top_right`): Aligmemnt of the dialog box.
		*    * `margin` (`Number`; default `4`): Margin (in pixels) for the dialog box.
		*    * `zindex` (`Number`; default `3000`): z-index of the popup/tooltip dialog.
		* * `field` (`Object`): Field default options.
		*    * `popup` (`Object`): Field popup options.
		*        * `alignment` (`Number`; default `WSForm.Alignments.top_left`): Alignment of the dialog box
		*          to the field.
		*        * `show_name` (`Boolean`; default `false`): Show the name of the field in the popup, regardless
		*          of whether or not it's a `placeholder` type.
		* * `tabs` (`Mixed`; default `false`): See below for tab usage.
		*    * `title` (`String`): Tab group title.
		*    * `fieldsets` (`Array`): An array of Strings or DOM elements defining each fieldset for this group.
		* * `classes` (`Object`): A key/value pair of the classes and their new classnames. (See below).
		* * `submit` (`Object`): Submission options. Unavailable when `halt` is disabled:
		*    * `method` (`String`; default `null`): One of the [[WSForm.SubmitMethods]] methods to use for submitting.
		*      If not defined, the form's default submission method is used.
		*    * `callback` (`Function`): An optional JavaScript function to execute, instead of submitting the form.
		*      The callback arguments are defined below. See __Callbacks__ below for more information.
		* * `messages` (`Object`): Array of message strings, inheriting from [[WSForm.Messages]], to use for
		*   display of the interface. Exposed as [[WSForm#messages]] for alteration after instantiation.
		*
		* #### Using tabs
		*
		* Tabs can be created in one of two ways. Either set the property to `true` to use simple tabs to seperate
		* the visible non-control fieldsets on the form, or create as an Array of Objects to customise grouped
		* fieldsets within each tab. The following shows an example of the Array syntax:
		*
		*     [{
		*         'title': 'Your Tab Title',
		*         'fieldsets': ['fieldset_1_id', 'fieldset_2_id']
		*     }, {
		*         'title': 'Another Tab Title',
		*         'fieldsets': ['fieldset_3_id']
		*     }]
		*
		* Fieldsets will be grouped within tabs, which will labelled as the `title` property defines. Fieldsets
		* not included within the object will be left as is, becoming omnipresent on the form.
		*
		* #### Classname overrides
		* The default classnames used by `WSForm` can be overridden at initialization by specifying the
		* `options.classes` option. The option is a hash of which each key is the class ID and value is
		* the actual classname used within the HTML. The following classes can be overridden:
		*
		* * `form` (default `ws-form`): Set on the form being managed.
		* * `ph` (default `placeholder`): The class looked for to register placeholder elements.
		* * `ph_active` (default `placeholder-active`): The class given to placeholder elements with `focus`.
		* * `ph_inactive` (default `placeholder-inactive`): The class given to placeholder elements without `focus`
		* (applied on the `blur` event).
		* * `label_text` (default `label-text`): Elements with this class are looked for when defining placeholder
		* labels to remove from visibility.
		* * `fieldset_control`: (default `control`): A fieldset with this classname is considered to be the 'control'
		* fieldset, which remains omnipresent when simple tabs are enabled.
		* * `tab_control`: (default `form-tab-control`): The classname given to the tab controller list placed at
		* the top of forms when tabs are enabled.
		* * `popup`: (default `form-handler-popup`): The classname given to the form's popup dialog/tooltip.
		*
		* #### `options.submit.callback` arguments
		* The following arguments are sent to the callback function:
		*
		* 1. `form` (`Object`): The HTML form element being handled.
		*
		* #### Callbacks
		*
		* The callback functions, when specified have are run under the following conditions:
		*
		* * The specified function can return `false` to halt further execution after the callback has fired.
		* * The `this` keyword within the callback at run time is registered to the WSForm instance.
		**/
		var cls, my;

		// !public interface
		cls = {
			/**
			* WSForm#validate([context]) -> Boolean
			* - context (Element): Fields only within this context will be checked.
			*
			* Validates a form, using the stored field data.
			*
			* Returns `true` if validation succeeded, `false` otherwise.
			**/
			validate: function() {
				return my.validate.apply(this, arguments);
			},

			/**
			* WSForm#validate_field(name) -> Object
			* - name (String): Name of the field to validate. This is the name as set by the
			* `name` attribute on the HTML field element.
			* - check (Object): Single requirements specification for this field. Will override
			* any requirement specification within [[WSForm.Fields]], and should be in the same
			* format.
			*
			* Validates a single field by name.
			*
			* Returns an Object defining the error result.
			*
			* ##### Returned object
			* The Object returned is similar in structure to the [[WSForm.Result]] class.
			**/
			validate_field: function() {
				return my.validate_field.apply(this, arguments);
			},

			/**
			* WSForm#value(element) -> Mixed
			* - element (Mixed): Name of, or the field to get the value from.
			*
			* Retrieves the value of a field (or collection of fields).
			*
			* Returns either an Array of values, a single value, or either an empty String or Array
			* if there is no value.
			**/
			value: function() {
				return my.value.apply(this, arguments);
			},

			/**
			* WSForm#tab(index) -> Mixed
			* - index (Number): Tab index to show.
			*
			* Switches the currently active tab, if enabled. A list of tabs can be retrieved with
			* [[WSForm#tabs]].
			*
			* Returns the active tab as an HTML element, or `false` if the index could not be found.
			**/
			tab: function(index) {
				if (my.tabs.items && my.tabs.items[index]) {
					// switch tab
					my.tabs.items[my.tabs.index].hide();
					my.tabs.items[index].show();

					// switch navigation
					my.tabs.control.children("li").slice(my.tabs.index, (my.tabs.index + 1)).removeClass("active");
					my.tabs.control.children("li").slice(index, (index + 1)).addClass("active");

					// set new index
					my.tabs.index = index;

					// clear message
					my.message("");

					return my.tabs.items[index];
				} else {
					return false;
				}
			},

			/**
			* WSForm#tabs() -> Array
			*
			* Returns the fieldsets managed as tabs.
			**/
			tabs: function(index) {
				return my.tabs.items;
			},

			/**
			* WSForm#has_field(field_name) -> Boolean
			* - field_name (String): `name` property of the field to check.
			*
			* Checks for the named field within the WSForm field data.
			*
			* Returns `true` if the field exists, `false` otherwise.
			**/
			has_field: function(field_name, options) {
				return !!(my.fields[field_name]);
			},

			/**
			* WSForm#add_field(field_name, options) -> Boolean
			* - field_name (String): `name` property of the field to be added.
			* - options (Mixed): Valid `WSForm.Fields` options value or the Boolean `true` to validate
			*
			* Adds a single field by name to be managed by WSForm. The `options` argument is identical to the
			* single option properties defined by [[WSForm.Fields]].
			*
			* Returns `true` on success, `false` if the field already exists.
			**/
			add_field: function(field_name, options) {
				var field;

				if (!form[0][field_name] || !(field = form[0][field_name])) {
					throw new Error("Form does not contain element with name '" + field_name + "'");
				}

				if (cls.has_field(field_name)) {
					return false;
				}

				my.fields[field_name] = options;

				form.find(my.options.selectors.elements.join(",")).each(function() {
					var element;

					element = $(this);

					if (element.attr("name") === field_name) {
						my.parse_element(element);
					}
				});

				return true;
			},

			/**
			* WSForm#remove_field(field_name) -> Boolean
			* - field_name (String): `name` property of the field to be removed.
			*
			* Removes a single field from the requirements data. Field will not be checked on next validation
			* and will need to be re-added by name for validation to act upon that field.
			*
			* Returns `true` on success, `false` if the field cannot be found.
			**/
			remove_field: function(field_name) {
				if (my.fields[field_name]) {
					my.clear(field_name);
					delete my.fields[field_name];
					return true;
				} else {
					return false;
				}
			},

			/**
			* WSForm#add_fault(result) -> Object
			* - result (Object): [[WSForm.Result]] object.
			*
			* Adds a single fault to the internal fault database. This fault will be listed alongside
			* all other naturally acquired faults when the form is submitted.
			*
			* The passed `result` argument should be an instance of the [[WSForm.Result]] Class.
			*
			* If using as part of a manual submission validation, the [[WSForm#report]] method can be
			* executed to display the resulting fault report.
			*
			* Returns the created result object.
			**/
			add_fault: function(result) {
				var field;

				if (!(result instanceof Object) ||
					typeof result.valid !== "boolean") {
					throw new Error("Invalid WSForms.Result Object passed");
				}

				if (typeof result.name !== "string" && result.name.length <= 0) {
					throw new Error("Result property 'name' must be set");
				} else if (!form[result.name] || !(field = form[result.name])) {
					throw new Error("Form does not contain element with name '" + result.name + "'");
				}

				this.remove_fault(result.name);

				my.faults.push(result);

				return result;
			},

			/**
			* WSForm#remove_fault(name) -> Boolean
			* - name (String): `name` property of the element to which the fault refers.
			*
			* Removes a single fault from the internal fault database.
			*
			* Returns `true` if the fault was found by element name, `false` otherwise.
			**/
			remove_fault: function(name) {
				var a;

				for (a = 0; a != my.faults.length; a += 1) {
					if (my.faults[a].name === name) {
						my.faults.splice(a, 1);
						return true;
					}
				}

				return false;
			},

			/**
			* WSForm#report([context]) -> Number
			* - context (Element; default `form`): Contextual element beside which to generate messages.
			*
			* Run and display a report on the form, highlighting any faults.
			*
			* Returns the number of faults found.
			**/
			report: function() {
				return my.report.apply(this, arguments);
			},

			/**
			* WSForm#message(message[, context][, options]) -> Undefined
			* - message (String): Message to display
			* - context (Element; default 'form'): Contextual element. Defaults to the form's
			*   primary submit input.
			* - options (Object): Options object, inherits from `options.popup`
			*
			* Display a simple message.
			**/
			message: function() {
				return my.message.apply(this, arguments);
			}
		};

		// !private properties and methods
		my = {
			elements: {},

			fields: {},

			controls: {},

			timers: {},

			options: ob_set(options || {}, {
				'halt': true,
				'tabs': false,
				'popup': {
					'type': WSForm.MsgTypes.Message,
					'alignment': WSForm.Alignments.top_right,
					'margin': 4,
					'zindex': 4000
				},
				'field': {
					'popup': {
						'alignment': WSForm.Alignments.top_left
					},
					'show_name': false
				},
				'submit': {
					'method': null,
					'callback': null
				},
				'live_validate': {
					'enabled': true,
					'delay': 0.5
				},
				'messages': {},
				'selectors': {
					'elements': [
						'input',
						'textarea',
						'select'
					]
				}
			}),

			faults: [],

			validation_re: {
				'email': new RegExp("^[a-z0-9-_.+]+@.+\\.[a-z.]*$", "i"),
				'number': new RegExp("^[0-9.+e]+$"),
				'date_iso': new RegExp("^(\\d{4})-(\\d\\d)-(\\d\\d)$"),
				'date': new RegExp("^(\\d\\d)([\\-\\/\\\\])(\\d\\d)\\2(\\d{4})$"),
				'email_parts': new RegExp("(.*)\\@([^.]*)\\.(.*)")
			},

			data: {
				'mail_domains': [
					"yahoo.com", "google.com", "hotmail.com", "gmail.com", "me.com", "aol.com", "mac.com",
					"live.com", "comcast.net", "googlemail.com", "msn.com", "hotmail.co.uk", "yahoo.co.uk",
					"facebook.com", "verizon.net", "sbcglobal.net", "att.net", "gmx.com", "mail.com", "whitespacers.com"
				]
			},

			classes: {
				'form': 'ws-form',
				'ph': 'placeholder',
				'ph_active': 'placeholder-active',
				'ph_inactive': 'placeholder-inactive',
				'label_text': 'label-text',
				'fieldset_control': 'control',
				'tab_control': 'form-tab-control',
				'tab_group': 'tab-group',
				'popup': 'form-handler-popup'
			},

			collectives: ["input[type = 'checkbox']", "input[type = 'radio']"],

			unlabelled: ['button', 'hidden', 'submit', 'image'],

			enable: function() {
				var fn, submit_buttons, a, fieldsets;

				form = $(form);

				if (typeof my.options.classes === "object") {
					my.classes = ob_set(my.options.classes, my.classes);
				}

				/**
				* WSForm#messages -> Object
				*
				* A set of message strongs, inherited from [[WSForm.Messages]], used to populate
				* the interface. These messages can be overwritten in the options on instantiation
				* or by altering the properties of this public property.
				**/
				cls.messages = window.ob_set(my.options.messages, WSForm.Messages);

				fn = {};

				// get and test form id
				my.form_id = form[0].id || form.attr("name");

				if (my.form_id !== null && typeof my.form_id !== "string") {
					throw new Error("Type error with form ID. The form id or name attribute " +
						"cannot be collected. This is likely due to an element with the name or " +
						"id of 'id'.");
				}

				// get field definition
				my.fields = ob_set(WSForm.Fields[my.form_id] || {}, fields);

				// get form elements
				my.form_elements = form.find(my.options.selectors.elements.join(","));

				my.form_elements.each(function() {
					my.parse_element(this);
				});

				if (my.form_elements.length > 0) {
					form.addClass(
						my.classes.form
					).data(
						"ws_form", true
					).bind(
						"submit", my.event
					).bind(
						"click", my.event
					).bind(
						"keyup", my.event
					);

					if (form.css("position") !== "absolute") {
						form.css({
							'position': 'relative'
						});
					}

					// add popup element
					form.append(
						my.popup = $("<div>", {
							'class': my.classes.popup
						}).css({
							'position': 'absolute',
							'white-space': 'nowrap',
							'zIndex': my.options.popup.zindex
						}).hide()
					);

					// add "novalidate" property to stop browser validation
					form.attr("novalidate", "novalidate");

					// find first visible submit button
					submit_buttons = form.find([
						"input[type = 'submit']",
						"input[type = 'image']",
						"button[type = 'submit']",
						"button"
					].join(",")).filter(":visible");

					if (submit_buttons.length > 0) {
						my.controls.submit = submit_buttons.first();
					} else {
						my.log("No visible submit button could be found for this form. Global errors will be registered to form context.");
					}
				}

				// tab control
				if (my.options.tabs) {
					fieldsets = form.find("fieldset:not([class~='control'])");

					my.tabs = {
						'items': []
					};

					form.prepend(
						my.tabs.control = $("<ul>", {
							'class': my.classes.tab_control
						})
					);

					fn.add_tab = function(fieldset) {
						// prepares fieldsets as tabbed groups
						var control_class, legend, index, label;

						legend = fieldset.find("legend").first();
						index = my.tabs.items.length;

						// get class name
						if (index === 0) {
							control_class = "first active";
						} else if (index === (fieldsets.length - 1)) {
							control_class = "last";
						} else {
							control_class = null;
						}

						// get label
						if (legend.length) {
							label = legend.text();
							legend.hide();
						} else {
							label = cls.messages.tab_step_prefix + (index + 1);
						}

						// insert tab controller
						my.tabs.control.append(
							$("<li>", {
								'class': control_class
							}).append(
								$("<a>", {
									'href': '#'
								}).bind(
									"click", function(event) {
										event.preventDefault();
										cls.tab(index);
									}
								).update(label)
							)
						);

						my.tabs.items.push(fieldset);

						if (index !== 0) {
							fieldset.hide();
						}
					};

					fn.add_grouped_tab = function(set, group) {
						var a, control_class, container, fieldset;

						// get class name
						if (group === 0) {
							control_class = "first active";
						} else if (group === (my.options.tabs.length - 1)) {
							control_class = "last";
						} else {
							control_class = null;
						}

						// insert tab controller
						my.tabs.control.append(
							$("<li>", {
								'class': control_class
							}).append(
								$("<a>", {
									'href': '#'
								}).bind(
									"click", function(event) {
										event.preventDefault();
										cls.tab(group);
									}
								).html(set.title || cls.messages.tab_step_prefix + group)
							)
						);

						if ((container = form.find("div." + my.classes.tab_group).slice(group + 1, group + 2)).length === 0) {
							my.tabs.control.after(
								container = $("<div>", {
									'class': my.classes.tab_group
								})
							);
						}

						for (a = 0; a < set.fieldsets.length; a += 1) {
							if ((fieldset = $("#" + set.fieldsets[a])).length > 0) {
								container.append(fieldset);
							} else {
								my.log("Fieldset with id '" + set.fieldsets[a] + "' could not be found for grouping.");
							}
						}

						my.tabs.items.push(container);

						if (group !== 0) {
							container.hide();
						} else {
							container.show();
						}
					};

					if (my.options.tabs.length &&
						(my.options.tabs = $(my.options.tabs))) {
						// loop through each group and add
						my.options.tabs.each(function(index) {
							fn.add_grouped_tab(this, index);
						});
					} else if (my.options.tabs === true) {
						// loop through each fieldset and add
						fieldsets.each(function(index) {
							// add tab
							fn.add_tab($(this));
						});
					}

					my.tabs.index = 0;
				}
			},

			parse_element: function(element) {
				var name, id, title, value, label, label_text, type, collective;

				element = $(element);
				name = element.attr("name");
				id = element.attr("id");
				title = element.attr("title");
				type = element.attr("type");
				label = form.find("label[for='" + id + "']").first();
				//field = my.field(name);

				if (element.disabled) {
					// skip file and disabled elements
					my.log("Skipping disabled element '" + name + "'.");
					return;
				}

				collective = my.is_collective(element);

				/*field type forcing based on valuetype - not for now. maybe later
				if (field && field.type) {
					switch (field.type) {
						case WSForm.ValueTypes.Date:
							element.attr("type", "date");
							break;
					}
				}*/

				if (id && label) {
					element.data("label", label);

					if (element.hasClass(my.classes.ph)) {
						if (title !== null) {
							if (collective) {
								throw new Error("Placeholders cannot be applied to collective element '" + name + "'.");
							}

							value = element.val();

							element.data(
								my.classes.ph, true
							).data(
								"title", title
							);

							if (value === "" || value === title) {
								element.val(title).removeClass(
									my.classes.ph_active
								).addClass(
									my.classes.ph_inactive
								);
							} else {
								element.addClass(my.classes.ph_active);
							}

							if (label.hasClass(my.classes.label_text)) {
								label_text = label;
							} else {
								// if a label span exists, hide it
								label_text = label.find("." + my.classes.label_text);
							}

							if (label_text.length > 0) {
								label_text.hide();
							} else {
								my.log(
									"No label or element with class '" + my.classes.label_text +
									"' could be found for placeholder element '" + name + "'"
								);
							}
						} else {
							// title not supplied
							my.log("Placeholder requested but no title attribute supplied for '" +
								name + "'.");
						}
					} else {
						if (title !== null) {
							element.data(
								"title", title
							);
						}
					}

					element.bind("focus", function(event) {
						my.focus(event, name);
					});

					element.bind("blur", function(event) {
						my.focus(event, name);
					});
				} else if (!label && my.unlabelled.indexOf(type) === -1) {
					// element is unlabelled - do not apply dialog events
					my.log("Could not find label for element '" + name + "'.");
				}

				if (name !== null) {
					if (my.elements[name] && collective) {
						// add to a collective field
						if (my.elements[name].length === 1) {
							my.elements[name] = [my.elements[name]];
						}

						my.elements[name].push(element);
					} else {
						my.elements[name] = element;
					}
				}
			},

			event: function(event) {
				var element, field;

				element = $(event.target);

				switch (event.type) {
					case "submit":
						my.submit(event);
						break;

					case "click":
						if (element === my.popup) {
							my.message("");
						}

						break;

					case "keyup":
						if (element.name &&
							(field = my.field(element.name)) &&
							typeof field === "object" &&
							field.live === true) {
							if (my.timers.live_validate) {
								window.clearTimeout(my.timers.live_validate);
								delete my.timers.live_validate;
							}

							my.timers.live_validate = window.setTimeout(function() {
								my.live_validate_field(element.name);
							}, (my.options.live_validate.delay * 1000));
						}
					}
			},

			submit: function(event) {
				var result, action, method;

				if (my.options.halt) {
					// stop form from submitting if halt is set
					event.preventDefault();
				}

				// clear all the placeholder elements
				my.clear();

				if ((result = cls.validate())) {
					// form is valid - handle (or not)
					method = form.attr("method");

					if (my.options.halt) {
						// only handle if halt is enabled
						if (typeof my.options.submit.callback !== "function" ||
							(typeof my.options.submit.callback === "function" &&
								my.options.submit.callback.apply(cls, [form]) !== false)) {
							// submit by appropriate method
							form.trigger("form:submitting", [
								my.options.submit.method || method
							]);

							switch (my.options.submit.method) {
								case WSForm.SubmitMethods.POST:
								case WSForm.SubmitMethods.GET:
									form.attr("method", my.options.submit.method);
									form[0].submit();
									break;

								case WSForm.SubmitMethods.AJAX:
									action = form.attr("action") || "/";

									new $.ajax(action, {
										'data': form.serialize(),
										'type': 'POST',
										'success': function() {
											form.trigger("form:submitted", arguments);
										}
									});
									break;

								default:
									form[0].submit();
							}
						}
					}
				} else {
					// form is invalid
					my.report();

					if (result === false && !my.options.halt) {
						// stop if form is not valid - regardless of halt option
						event.preventDefault();
					}

					form.trigger("form:error", [
						form,
						my.faults
					]);
				}
			},

			validate: function(context, fields) {
				// validate form
				var name, field, result, a, ancestors, do_cascade;

				if (fields === undefined) {
					// first check - clear faults
					my.faults = [];
				}

				fields = fields || my.fields || null;

				do_cascade = function(cascade, value) {
					return (
						(typeof cascade.value === "undefined" && value !== "") ||
						(cascade.value === true && value !== "") ||
						(cascade.value === false && value === "") ||
						(cascade.value && cascade.value == value) ||
						(cascade.value && my.value_in_array(cascade.value, value))
					);
				};

				if (fields !== null) {
					for (name in fields) {
						if (fields.hasOwnProperty(name) && my.elements[name]) {
							// element exists in collection
							field = fields[name];

							if (context) {
								// get contextual element
								if (my.elements[name].constructor === Array && my.elements[name].length) {
									ancestors = $(my.elements[name][0]).ancestors();
								} else {
									ancestors = $(my.elements[name]).ancestors();
								}
							}

							if ((!context) || (context && ancestors.indexOf(context) !== -1)) {
								// element exists within context (or context is not defined)
								result = my.validate_field(name);

								if (result.valid === false) {
									my.faults.push(result);
								}

								if ((typeof field.cascade === "object" && result.valid === true)) {
									if (field.cascade.length) {
										for (a = 0; a < field.cascade.length; a += 1) {
											if (do_cascade(field.cascade[a], result.value)) {
												this.validate(context, field.cascade[a].fields);
											}
										}
									} else {
										if (do_cascade(field.cascade, result.value)) {
											this.validate(context, field.cascade.fields);
										}
									}
								}
							}
						}
					}
				}

				return (my.faults.length === 0);
			},

			live_validate_field: function(name, check) {
				// runs live validation on a field (which results in 'softer' messages)
				var result;

				check = check || my.field(name);
				result = my.validate_field(name, check, false);

				if (result.suggestion !== undefined) {
					// display a message
					my.message(
						cls.messages.did_you_mean + "&lsquo;<b>" + result.suggestion + "</b>&rsquo; ?",
						result.element, {
							'type': WSForm.MsgTypes.Message
						}
					);
				} else {
					my.message("");
				}
			},

			validate_field: function(name, check) {
				// validate a single field
				var require_value, result, value, suggestion,
					num_value, el, duplicate_value,
					date, date_parts;

				check = check || my.field(name);
				el = my.elements[name];
				require_value = (check.require || check === true);

				result = new WSForm.Result(name);

				if (check && el) {
					value = my.value(el);
					num_value = parseFloat(value);

					result.value = value;
					result.element = el;

					if ((typeof check === "object") || check === true) {
						if (require_value && (value === "" || value.length === 0)) {
							// value required
							result.valid = false;
						}

						// imply numeric when max/min are specified
						if (check.min !== undefined || check.max !== undefined) {
							check.type = WSForm.ValueTypes.Number;
						}

						// value required or type constraint
						if (result.valid && check.type !== undefined) {
							switch (check.type) {
								case WSForm.ValueTypes.Email:
									// test value for a valid email address
									if (!value.match(my.validation_re.email) && (value !== null || value !== "" || check.require)) {
										result.type = check.type;
										result.valid = false;
									} else {
										suggestion = my.utils.suggest_email(value);

										if (suggestion !== false && suggestion !== value) {
											result.suggestion = suggestion;
										}
									}
									break;

								case WSForm.ValueTypes.Number:
									// test value for a valid number
									if (!value.match(my.validation_re.number) && (value !== "" || check.require)) {
										result.type = check.type;
										result.valid = false;
									}
									break;

								case WSForm.ValueTypes.Date:
									// test value for a valid date (YYYY-MM-DD)
									if ((date = value.match(my.validation_re.date_iso))) {
										date_parts = [date[1], date[2], date[3]];
									} else if ((date = value.match(my.validation_re.date))) {
										date_parts = [date[4], date[3], date[1]];
									} else if (value !== "" || check.require) {
										result.type = check.type;
										result.valid = false;
									}

									if (date_parts) {
										// create date object
										if (date_parts[1] > 12 || date_parts[1] < 1) {
											result.type = check.type;
											result.valid = false;
										} else if (date_parts[2] > 31 || date_parts[2] < 1) {
											result.type = check.type;
											result.valid = false;
										} else {
											date = new Date(date_parts[0], date_parts[1], date_parts[2]);

											if (isNaN(date.valueOf())) {
												result.type = check.type;
												result.valid = false;
											}
										}
									}
									break;

								case WSForm.ValueTypes.RegExp:
									// test value against a regexp
									if (check.regexp) {
										if (!check.regexp.test(value) && (value !== "" || check.require)) {
											result.type = check.type;
											result.valid = false;
										}
									}
									break;

								default:
									my.log("Invalid check type defined for field '" + name + "'");
							}
						}

						// value required or min/max numeric amount constraints
						if (result.valid) {
							if ((check.min !== undefined || check.max !== undefined) &&
								!isNaN(num_value)) {
								if (check.min !== undefined && num_value < check.min) {
									result.value_min = true;
									result.required_value = check.min;
									result.valid = false;
								}

								if (check.max !== undefined && num_value > check.max) {
									result.value_max = true;
									result.required_value = check.max;
									result.valid = false;
								}
							}

							// run the folowing constraints if there is a value
							if (value.length > 0) {
								// min length constraint
								if (check.min_len !== undefined &&
									value.length < check.min_len) {
									result.value_min_len = true;
									result.required_value = check.min_len;
									result.valid = false;
								}

								// max length constraint
								if (check.max_len !== undefined && value.length > check.max_len) {
									result.value_max_len = true;
									result.required_value = check.max_len;
									result.valid = false;
								}
							}
						}

						if (check.duplicate_of && my.elements[check.duplicate_of] !== undefined) {
							duplicate_value = my.value(my.elements[check.duplicate_of]);

							if (duplicate_value !== value) {
								result.mismatch = check.duplicate_of;
								result.valid = false;
							}
						}
					}

					return result;
				} else {
					if (!check) {
						// validate_field() has most likely been run manually but no requirement exists for this element
						return result;
					} else {
						throw new Error("Element '" + name + "' could not be found within the form");
					}
				}
			},

			clear: function(field_name) {
				// clear all fields before submission
				var field, el, fn;

				fn = {
					highlight: function() {
						my.highlight($(this), false);
					}
				};

				for (field in my.elements) {
					if (my.elements.hasOwnProperty(field) &&
						(field === field_name || field_name === undefined)) {
						el = my.elements[field];

						if (el.length > 1) {
							// array of elements
							$(el).each(fn.highlight);
						} else {
							// single element
							if (el.data(my.classes.ph) === true && el.val() === el.data("title")) {
								// clear placeholder field
								el.val("");
							}

							my.highlight(el, false);
						}
					}
				}
			},

			report: function(context) {
				// highlights form elements within the my.faults array
				var field, fn, a;

				fn = function() {
					field = my.elements[this.name];

					my.log("'" + this.name + "' found to contain fault(s).");

					if (field.length > 1) {
						for (a = 0; a < field.length; a += 1) {
							my.highlight(field[a]);
						}
					} else {
						my.highlight(field);
					}
				};

				if (my.faults.length > 0) {
					// highlight faulty elements
					$(my.faults).each(fn);

					if (context === undefined) {
						context = form;
					}

					my.message(cls.messages.general_error, context, {
						'type': WSForm.MsgTypes.Error
					});
				}

				return my.faults.length;
			},

			highlight: function(field, highlight) {
				var label, parent;

				label = field.data("label");

				if (highlight === undefined) {
					highlight = true;
				}

				if (label !== undefined) {
					parent = label.parent().first();

					if (highlight) {
						label.addClass("required");
					} else {
						label.removeClass("required");
					}

					if (parent.length && $.contains(form[0], parent[0])) {
						// highlight parent
						if (highlight) {
							parent.addClass("required");
						} else {
							parent.removeClass("required");
						}
					}
				}
			},

			focus: function(event, name) {
				var fault, el, field, options, placeholder, field_label, message, title;

				if (!my.elements[name]) {
					return;
				}

				el = my.elements[name];
				field = my.field(name);
				options = {};

				if (field && field.popup && field.popup.alignment) {
					options.alignment = field.popup.alignment;
				} else if (my.options.field && my.options.field.popup && my.options.field.popup.alignment) {
					options.alignment = my.options.field.popup.alignment;
				} else {
					options.alignment = WSForm.Alignments.top_left;
				}

				if (event.type === "focus") {
					// element is being focused
					fault = my.fault(name);

					if (el) {
						if (!$.isArray(el)) {
							title = el.data("title");
							placeholder = (el.data(my.classes.ph) === true);

							if (placeholder && my.value(el) === el.data("title")) {
								el.val("").removeClass(
									my.classes.ph_inactive
								).addClass(
									my.classes.ph_active
								);
							}
						}

						if (fault) {
							// fault exists for this field
							if (fault.type) {
								if (field && field.messages && field.messages.type) {
									message = field.messages.type;
								} else {
									switch (fault.type) {
										case WSForm.ValueTypes.Email:
											message = cls.messages.type_email;
											break;

										case WSForm.ValueTypes.Number:
											message = cls.messages.type_number;
											break;

										case WSForm.ValueTypes.Date:
											message = cls.messages.type_date;
											break;

										case WSForm.ValueTypes.RegExp:
											message = cls.messages.type_regex;
											break;
									}
								}
							} else if (fault.value_min) {
								if (field.messages && field.messages.value_min) {
									message = field.messages.value_min;
								} else {
									message = cls.messages.value_min;
								}
							} else if (fault.value_max) {
								if (field.messages && field.messages.value_max) {
									message = field.messages.value_max;
								} else {
									message = cls.messages.value_max;
								}
							} else if (fault.value_max_len) {
								if (field.messages && field.messages.value_max_len) {
									message = field.messages.value_max_len;
								} else {
									message = cls.messages.value_max_len;
								}
							} else if (fault.value_min_len) {
								if (field.messages && field.messages.value_min_len) {
									message = field.messages.value_min_len;
								} else {
									message = cls.messages.value_min_len;
								}
							} else if (fault.mismatch) {
								// field mismatched to its duplicate
								field_label = my.element_label(my.elements[fault.mismatch]);

								if (field.messages && field.messages.mismatch) {
									message = field.messages.mismatch;
								} else {
									message = cls.messages.field_mismatch;
								}
							} else {
								// basic field value
								if (field && field.messages && field.messages.require) {
									message = field.messages.require;
								} else {
									message = cls.messages.field_value;
								}
							}

							if (typeof message === "string") {
								message = message.replace(/\$1/, field_label || "");
								message = message.replace(/\$2/, fault.required_value);
								message = message.replace(/\$3/, fault.value);
							} else {
								message = "";
							}

							// placeholder elements
							if ((placeholder || my.options.field.popup.show_name) && title) {
								message = title + " - " + message;
							}

							options.type = WSForm.MsgTypes.Error;

							my.message(message, el, options);
						} else if (placeholder) {
							my.message(title, el, options);
						}
					}
				} else {
					// element is being blurred (or not focused)
					if (el && !$.isArray(el)) {
						placeholder = (el.data(my.classes.ph) === true);

						if (placeholder && my.value(el) === "") {
							el.val(
								el.data("title")
							).removeClass(
								my.classes.ph_active
							).addClass(
								my.classes.ph_inactive
							);
						}
					}

					my.message("");
				}
			},

			field: function(find, fields) {
				// attempt to find an item within this.fields based on name
				var item, name, a;

				fields = fields || my.fields;

				for (name in fields) {
					if (fields.hasOwnProperty(name)) {
						if (item !== undefined) {
							break;
						}

						if (name === find) {
							item = fields[name];
						}

						if (item === undefined && fields[name].cascade) {
							if (fields[name].cascade.length) {
								for (a = 0; a < fields[name].cascade.length; a += 1) {
									if (typeof fields[name].cascade[a].fields === "object") {
										item = my.field(find, fields[name].cascade[a].fields);

										if (item !== undefined) {
											break;
										}
									}
								}
							} else if (typeof fields[name].cascade.fields === "object") {
								item = my.field(find, fields[name].cascade.fields);
							}
						}
					}
				}

				return item;
			},

			value: function(el) {
				// get element value
				var a, values, value, result;

				if (typeof el === "string") {
					if (my.elements[el]) {
						el = my.elements[el];
					} else {
						throw new Error("Element '" + arguments[0] + "' could not be found");
					}
				}

				if (el.length > 1) {
					// return multiple items
					values = "";

					for (a = 0; a < el.length; a += 1) {
						if (el[a].attr("type") === "radio") {
							// only one value is collected
							if ((value = my.element_value(el[a]))) {
								values = value;
								break;
							}
						} else {
							// multiple values are collected
							if ((value = my.element_value(el[a]))) {
								if (values === "") {
									values = [];
								}

								values.push(value);
							}
						}
					}

					result = values;
				} else {
					// return single item
					result = my.element_value(el);
				}

				return result;
			},

			element_value: function(el) {
				// gets the value of a single element
				var value;

				value = "";

				if (my.is_collective(el)) {
					if (el.prop("checked")) {
						value = el.val() || "";
					}
				} else {
					value = el.val() || "";

					if (typeof value === "string") {
						value = $.trim(value);
					}
				}

				return value;
			},

			element_label: function(el) {
				// attempt to data the element's label
				var label, span;

				label = el.data("label");

				if (label) {
					span = label.down("span.label-text");

					if (span) {
						// span with a class of label-text exists
						return (span.textContent ? span.textContent : span.innerText);
					} else {
						// get entire label text content
						return (label.textContent ? label.textContent : label.innerText);
					}
				} else {
					// no label - just get the title attribute
					return el.attr("title");
				}
			},

			is_collective: function(el) {
				var key;

				for (key in my.collectives) {
					if (my.collectives.hasOwnProperty(key) &&
						el.is(my.collectives[key])) {
						return true;
					}
				}

				return false;
			},

			value_in_array: function(value, array) {
				// attempt to find [value] in [array]
				var a;

				if (!array.length) {
					return false;
				}

				if (typeof value === "string") {
					return (array.indexOf(value) !== -1);
				} else if (value.length) {
					for (a = 0; a < value.length; a += 1) {
						if (array.indexOf(value[a]) !== -1) {
							return true;
						}
					}
				}

				return false;
			},

			fault: function(find) {
				// attempt to find a fault
				var item;

				for (item in my.faults) {
					if (my.faults.hasOwnProperty(item) && my.faults[item].name === find) {
						return my.faults[item];
					}
				}
			},

			message: function(message, context, options) {
				var pos, context_size, popup_size;

				my.popup.removeClass("popup-type-error");
				my.popup.removeClass("popup-type-message");

				if (message !== "") {
					context = context || form;
					options = ob_set(options || {}, my.options.popup);

					switch (options.type) {
						case WSForm.MsgTypes.Error:
							my.popup.addClass("popup-type-error");
							break;

						case WSForm.MsgTypes.Message:
							my.popup.addClass("popup-type-message");
							break;
					}

					if (context === form) {
						// context is the entire form
						if (my.controls.submit) {
							// place at last submit button
							context = my.controls.submit;
						} else {
							// keep at form level
							context = form;
						}
					}

					if (context.length > 1) {
						context = context.first();
					}

					pos = context.formOffset();

					my.popup.css({
						'display': 'block',
						'visibility': 'hidden'
					}).html(message);

					popup_size = {
						'height': my.popup.outerHeight(),
						'width': my.popup.outerWidth()
					};

					context_size = {
						'height': context.outerHeight(),
						'width': context.outerWidth()
					};

					switch (options.alignment) {
						case WSForm.Alignments.bottom_left:
							my.popup.css({
								'top': (pos.top + context_size.height + options.margin) + 'px',
								'left': pos.left + 'px'
							});
							break;

						case WSForm.Alignments.bottom_right:
							my.popup.css({
								'top': (pos.top + context_size.height + options.margin) + 'px',
								'left': (pos.left - (popup_size.width - context_size.width)) + 'px'
							});
							break;

						case WSForm.Alignments.top_left:
							my.popup.css({
								'top': ((pos.top - popup_size.height) - options.margin) + 'px',
								'left': pos.left + 'px'
							});
							break;

						default:
							my.popup.css({
								'top': ((pos.top - popup_size.height) - options.margin) + 'px',
								'left': (pos.left - (popup_size.width - context_size.width)) + 'px'
							});
							break;
					}

					my.popup.css({
						'visibility': 'visible'
					});
				} else {
					my.popup.hide();
				}
			},

			log: function(msg) {
				// log event to the console (if active)
				if (typeof console !== "undefined") {
					console.log(msg);
				}
			},

			utils: {
				suggest_email: function(email) {
					// returns a 'suggestion' email (or the same email if none found)
					var a, parts, closest, min_distance, distance_threshold, find_domain;

					if (typeof email === "string") {
						parts = email.match(my.validation_re.email_parts);

						if (parts && parts.length === 4) {
							parts = {
								'email': parts[0],
								'user': parts[1],
								'domain': parts[2] + '.' + parts[3],
								'tld': parts[3]
							};

							min_distance = 99;
							closest = null;
							distance_threshold = 3;

							find_domain = function(domain, data) {
								// find domain
								var closest, a, data_domain, dist;

								closest = null;

								for (a = 0; (data_domain = data[a]); a += 1) {
									if (data_domain === domain) {
										// domain is exactly this one
										closest = domain;
										break;
									}

									// get distance
									dist = my.utils.sift3_distance(data_domain, domain);

									if (dist < min_distance) {
										closest = data_domain;
										min_distance = dist;
									}
								}

								if (min_distance < distance_threshold && closest !== null) {
									// domain is close to a stored domain
									if (closest !== domain) {
										return closest;
									} else {
										return null;
									}
								} else {
									return null;
								}
							};

							closest = find_domain(parts.domain, my.data.mail_domains);

							if (closest !== null) {
								if (closest !== parts.domain) {
									return closest;
								} else {
									return false;
								}
							} else {
								return false;
							}
						} else {
							return false;
						}
					} else {
						return false;
					}
				},

				sift3_distance: function(s1, s2) {
					// sift3: http://siderite.blogspot.com/2007/04/super-fast-and-accurate-string-distance.html
					var i, c, offset1, offset2, lcs, max_offset;

					if (s1 === null || s1 === undefined || s1.length === 0) {
						if (s2 === null || s2 === undefined || s2.length === 0) {
							return 0;
						} else {
							return s2.length;
						}
					}

					if (s2 === null || s2 === undefined || s2.length === 0) {
						return s1.length;
					}

					c = 0;
					offset1 = 0;
					offset2 = 0;
					lcs = 0;
					max_offset = 5;

					while ((c + offset1 < s1.length) && (c + offset2 < s2.length)) {
						if (s1.charAt(c + offset1) == s2.charAt(c + offset2)) {
							lcs += 1;
						} else {
							offset1 = 0;
							offset2 = 0;

							for (i = 0; i < max_offset; i += 1) {
								if ((c + i < s1.length) && (s1.charAt(c + i) == s2.charAt(c))) {
									offset1 = i;
									break;
								}

								if ((c + i < s2.length) && (s1.charAt(c) == s2.charAt(c + i))) {
									offset2 = i;
									break;
								}
							}
						}

						c += 1;
					}

					return ((s1.length + s2.length) / 2 - lcs);
				}
			}
		};

		my.enable();

		return cls;
	};

	/**
	* WSForm.ValueTypes
	* The various value type constraints which can be applied to field requirements:
	*
	* * `Email`: A valid, complete email address.
	* * `Number`: A valid logical or extended number.
	* * `RegExp`: A regular expression against which the value will be matched.
	* * `Date`: A valid date. Constraints will be applied to the month and day values.
	**/
	WSForm.ValueTypes = {
		'Email': 1,
		'Number': 2,
		'RegExp': 3,
		'Date': 4
	};

	/**
	* WSForm.Fields
	* This object defines the fields that WSFormHandler checks when submitting a form.
	* The fields are a key/value hash of field names as set with the `name` attribute of
	* the actual HTML elements on the form being parsed. You can simply set the field value
	* to `true` if checking for any value.
	*
	* Forms can be defined either by augmenting the WSForm.Fields hash before or
	* during initialization of the class. If a form is defined before initialization, its
	* fields are augmented by any fields passed to [[WSForm]].
	*
	* An example fields hash could look as follows:
	*
	*     WSForm.Fields['your_form_id'] = {
	*       'name': true,
	*       'email': {
	*           'require': true,
	*           'type': WSForm.ValueTypes.Email,
	*           'cascade': {
	*               'fields': {
	*                   'email_confirm': {
	*                       'require': true,
	*                       'type': WSForm.ValueTypes.Email
	*                   }
	*               }
	*       }
	*       'postcode': true
	*       'account_number': {
	*           'type': WSForm.ValueTypes.Number
	*       }
	*     }
	*
	* The following options can be defined for each field.
	*
	* * `require` (`Boolean`): Set `true` to require a value for the field, `false` otherwise.
	* * `popup` (`Object`): Popup dialog options.
	*    * `alignment` (`Number`): One of the [[WSForm.Alignments]] alignments for the popup dialog.
	* * `type` (`Number`): One of the [[WSForm.ValueTypes]] types. Used for constraining to a
	*   specific type of value. If the type `WSForm.ValueTypes.RegExp` is used, the `regexp` option
	*   should also be defined.
	* * `regexp` (`RegExp`): A `RegExp` object defining the mask against which the value should match.
	*   Applied when the `type` option is set to `WSForm.ValueTypes.RegExp`.
	* * `duplicate_of`: (`String`): When supplied, the field must have a duplicate value to the field
	* * `min`: (`Number`): Minimum value (when `type` is specified as `WSForm.ValueTypes.Number`)
	* * `max`: (`Number`): Maximum value (when `type` is specified as `WSForm.ValueTypes.Number`)
	* * `min_len`: (`Number`): Minimum value length. Can be zero if field is not required.
	* * `max_len`: (`Number`): Maximum value length.
	* * `live`: (`Boolean`): Enable live email validating for this field. Will attempt to validate
	*   against popular email hosts for common typgographical errors.
	* * `cascade` (`Object`, `Array`): Defines another hash, similar in structure to `WSForm.Fields`.
	*   the value can be either a single Object defining requirements, or an Array of Objects, each with
	*   a different required value.
	*    * `value` (`Mixed`): Defines a required value of the parent field before cascading is performed.
	*      either a single string value, an array of values on which to match, `true` to require any
	*      value or combination of values or `false` to require no value.
	*    * `fields` (`Object`): A key/value hash of fields to require when the requirements for
	*      the parent field have been met.
	* * `messages` (`Object`): Custom error messages for this field. When specified, will replace the
	* default message depending on the fault.
	*    * `require` (`String`): Custom empty value error message.
	*    * `type` (`String`): Custom type mismatch error message.
	*    * `mismatch` (`String`): Custom duplicate field value mismatch error message. `$1` can be used
	*      to define the duplicate field's label, and will be replaced at runtime.
	*    * `value_min`: (`String`): Custom 'minimum value' error message
	*    * `value_max`: (`String`): Custom 'maximum value' error message
	*    * `value_min_len`: (`String`): Custom 'minimum character length' error message
	*    * `value_max_len`: (`String`): Custom 'maximum character length' error message
	**/
	WSForm.Fields = {};

	/**
	* WSForm.MsgTypes
	* The various message types the popup dialog can take:
	*
	* * `Error`: Error message
	* * `Message`: General notification message.
	**/
	WSForm.MsgTypes = {
		'Error': 1,
		'Message': 2
	};

	/**
	* WSForm.Messages
	* A set of message strings for use with error reporting by the `WSForm` Class. The following
	* messages are available:
	*
	* * `general_error`: The error shown when a form is submitted.
	* * `field_value`: Appears above a required field on focus.
	* * `field_mismatch`: When the field type does not match a required duplicate.
	* * `type_email`: When the field value is not of type `WSForm.ValueTypes.Email`.
	* * `type_number`: When the field value is not of type `WSForm.ValueTypes.Number`.
	* * `type_regex`: When the field value is not of type `WSForm.ValueTypes.RegExp`.
	* * `value_min`: When the field value is numeric, and lower than the minimum value required.
	* * `value_max`: When the field value is numeric, and higher than the maximum value required.
	* * `value_min_len`: When the field's character length is below the required amount.
	* * `value_max_len`: When the field's character length is above the required amount.
	*
	* #### Placeholder keys
	*
	* Placeholder keys can also be used to produce dynamic values. The following keys are available:
	*
	* * '$1': Label for the required duplicate field. Only when duplicates are required
	* * '$2': Required value for the field.
	* * '$3': Current value of the field.
	**/
	WSForm.Messages = {
		// !messages
		'general_error': 'Please check for errors before sending',
		'field_value': 'Must be filled in',
		'field_mismatch': 'Must be identical to \'$1\'',
		'tab_step_prefix': 'Step ',
		'type_email': 'Must be a valid email',
		'type_number': 'Must be a valid number',
		'type_regex': 'Value is in an incorrect format',
		'type_date': 'Value is an invalid date',
		'value_min': 'Value must be a minimum of $2',
		'value_max': 'Value must be a maximum of $2',
		'value_min_len': 'Must contain a minimum $2 characters',
		'value_max_len': 'Must contain a maximum $2 characters',
		'did_you_mean': 'Did you mean '
	};

	/**
	* WSForm.Alignments
	* A set of alignments used to position the popup dialog box. The alignments are `top_left`,
	* `top_right`, `bottom_left` and `bottom_right`.
	**/
	WSForm.Alignments = {
		// !alignments
		'top_left': 1,
		'top_right': 2,
		'bottom_left': 3,
		'bottom_right': 4
	};

	/**
	* WSForm.SubmitMethods
	* These submit methods will override the form's pre-defined submit method. The following
	* methods are available:
	*
	* * `POST`: The form will be POSTed using the `action` attribute as a destination.
	* * `GET`: The form will be submitted using GET, with the `action` attribute as a destination.
	* * `AJAX`: A simple AJAX request will be sent to the destination defined in the `action` attribute.
	*   If none is defined, the AJAX request will be sent to the root. (Usually '/'). Once an AJAX
	*   request has been completed (by way of the onComplete option), the `form:submitted` event is fired.
	**/
	WSForm.SubmitMethods = {
		// !submit methods
		'POST': 'post',
		'GET': 'get',
		'AJAX': 'ajax'
	};

	/**
	* class WSForm.Result
	*
	* The WSForm.Result class is an object used to determine the status of a field when
	* a report is created using [[WSForm#validate_field]]. Is is also used by
	* [[WSForm#add_fault]].
	**/
	WSForm.Result = function(name, options) {
		/**
		* new WSForm.Result(name[, options])
		* - name (String): HTML Form element name.
		* - options (Object): Options object detailed below.
		*
		* #### `options` Object
		*
		* The `options` object contains the following properties:
		*
		* * `valid`: (`Boolean`; default `true`): `true` if the field is valid, `false` otherwise. Required.
		* * `value`: (`Mixed`): The computed value of the field returned by [[WSForm#value]].
		* * `name`: (`String`): The field's name. Passed back for sanity checking. Required.
		* * `type`: (`Number`): One of the [[WSForm.ValueTypes]] keys, if the field's type
		* was incorrect.
		* * `mismatch`: (`Boolean`): `true` if the field did not match its counterpart
		* `duplicate_of` requirement.
		* * `value_min` (`Number`): Minimum value specified by the [[WSForm.Fields]] item.
		* * `value_max` (`Number`): Maximum value specified by the [[WSForm.Fields]] item.
		* * `required_value` (`Mixed`): String or Number representing the required value of the field.
		* used by the [[WSForm.Messages]] placeholder keys (key '$2').
		**/
		var result;

		result = ob_set(options || {}, {
			'valid': true,
			'required_value': '',
			'value': ''
		});

		result.name = name;

		return result;
	};

	window.WSForm = WSForm;
}(window.jQuery, window.ob_set));

//Sourced from: jquery.ws-carousel.js, updated: 30 October 2013 11:38 am
/*global setTimeout: false, clearTimeout: false */
/**
* == WSCarousel ==
**/

/** section: WSCarousel
* class WSCarousel
*
* The WSCarousel class can be used for creating simple carousel-like transitions
* between indexable content within a common container. This class is a simpler,
* less customisable version of [[WSSlideShow]] and should be used when full
* slideshow functionality is not required.
**/
(function($, ob_set) {
	var WSCarousel = function(container, options) {
		/**
		* new WSCarousel(container[, options])
		* - container (Element): DOM element containing the indexable content.
		* - options (Object): Initialization options (see below).
		*
		* Create a new WSCarousel instance.
		*
		* #### Options
		* The `options` Object is structured as follows:
		* (__The following options are still a work-in-progress__)
		*
		* * `interactive` (`Boolean`; default `true`): If set to `false`, the carousel is assumed to be
		*   non-interactive and will not stop when the cursor is over it.
		* * `base_zindex` (`Number`; default `1`): The base z-index of the carousel.
		* * `id` (`String`): The id of the created container element (if required).
		* * `animation` (`Object`): Animation options.
		*   * `automated` (`Boolean`; default `true`): Automate slide progression.
		*   * `type` (`Object`; default [[WSCarousel.Animations.fade]]): Animation function.
		*   * `easing` (`String`; default `swing`): easing method. Supports extended easing properties.
		*   * `delay` (`Number`; default `5`): Delay between each slide in seconds.
		*   * `duration` (`Number`; default `0.3`) Transition duration in seconds.
		*   * `finish` (`Function`; default `null`): Callback to execute on after a slide transition.
		*     Executed after a transition but before cleaning up.
		* * `start`: (`Number`; default `0`): Defines the index for the starting slide.
		* * `callbacks`:
		*   * `pre_advance`: (`Function`; default `null`): Callback to execute before a slide transition.
		*   * `post_advance`: (`Function`; default `null`): Callback to exectue on completion a slide transition.
		* * `selectors`:
		*   * `items`: (`String`; default 'li'): Selector for individual slide items.
		* * `navigation`: (`Mixed`): Can be set `false`, `true` or to an object with the following properties:
		*   * `display`: (`Boolean`): Set `false` to not display the navigation, in the case that other settings
		*     within this object are required. `true` or omit setting to enable.
		*   * `alignment`: (`Mixed`; default WSCarousel.Alignments.center): Vertical alignment for navigation.
		*     use `false` to disable alignment.
		*   * `swipe`: (`Boolean`): `true` to enable finger swipe gestures on compatible devices,
		*     `false` or omit to disable.
		* * `pagination`: (`Mixed`): Can be set `false`, `true` or to an object with the following properties:
		*   * `alignment`: (`Mixed`; WSCarousel.Alignments.center): Horizontal alignment for navigation.
		*     use `false` to disable alignment.
		* * `styles`: (`Object`): Default carousel styles.
		*   * `container`:
		*      * `position`: 'relative'
		*   * `carousel`:
		*      * `overflow`: 'hidden'
		*      * `position`: 'relative'
		*      * `margin`: '0'
		* * `swipe`: (`Object`): Swipe settings:
		*   * `distance_trigger`: (`Number`): Distance in pixels the cursor or pointer must move to trigger
		*     swiping action in either direction.
		*   * `time`: (`Number`): In milliseconds, the maximum time allowed to register a valid swipe.
		*
		**/
		var my, cls;

		cls = {
			/**
			* WSCarousel#animation -> Object
			*
			* An Object containing information about the current transition.
			* This Object is filled with relevant data for the current transition when
			* a new slide is selected, before the animation function is run and can be
			* accessed by any methods within the scope of the class instance. The following
			* properties are stored within this Object:
			*
			* * `index` (`Number`): The index of the selected slide within [[WSCarousel#items]]
			* * `direction` (`Number`): The current direction of the transition. Negative for backwards
			*   transitions throughout the slide set or positive for forward transitions.
			* * `current` (`Element`): The current slide Element.
			* * `next` (`Element`): The next (or selected) slide Element.
			**/
			animation: {},

			/**
			* WSCarousel#set(options) -> undefined
			* - options (Object): Options for setting
			*
			* Set new options for the carousel instance. The options should follow the same
			* format as those defined in [[WSCarousel]].
			*
			* New options can be defined in full or part by abstract. Those not defined will
			* remain as previously set (or default).
			**/
			set: function(opt) {
				options = ob_set(opt, options);
			},

			/**
			* WSCarousel#go(adjustment) -> undefined
			* - adjustment (Number): Numeric adjustment for advancement.
			*
			* Advance the carousel by `adjustment` slides.
			* Negative numbers will reverse the carousel.
			**/
			go: function() {
				return my.go.apply(this, arguments);
			},

			/**
			* WSCarousel#select(index) -> undefined
			* - index (Number): Slide index to advance to.
			*
			* Advance to a specific slide by index.
			**/
			select: function() {
				return my.select.apply(this, arguments);
			},

			/**
			* WSCarousel#adjust([effects]) -> Mixed
			* - effects (Array): Array of effects to build upon.
			*
			* When `effects` is supplied, will return the supplied array with aditional
			* adjustment effects. Otherwise it will perform instant adjustment of the carousel
			* metrics based on the current container dimensions.
			*
			* Adjust is used internally for adding carousel adjustment effects to a transition
			* and is rarely required for external use except for on-demand metrics adjustments
			* when the outside dimensions of the carousel are altered. For instance when a media
			* aware CSS change is performed.
			*
			* If [[WSCarousel#adjust]] is run while a transition is taking place, the transition
			* will be immediately halted and the defined animation handler will be executed with
			* the `reset` argument set to `true`.
			**/
			adjust: function() {
				return my.adjust.apply(this, arguments);
			},

			/**
			* WSCarousel#cancel() -> undefined
			*
			* Cancels the current transition (if running) and executes the animation function
			* with the `reset` argument set to `true`.
			**/
			cancel: function() {
				return my.cancel.apply(this, arguments);
			},

			/**
			* WSCarousel#animate(elements, properties[, opt]) -> Object
			* - elements (Object): jQuery element(s) to animate.
			* - properties (Object): Object defining the CSS properties to animate into.
			* - opt (Object): Object defining the animation options.
			*
			* Adds an animation request to the currently animation queue. The specified `elements`
			* will be animated to `properties` CSS properties.
			*
			* `opt` options can be specified, which are inherited from jQuery's animate() method.
			* The `queue` option in this case is immutable from the internal queueing system used by
			* WSCarousel. `duration` and `easing` defualt to the global options declared on
			* instantiation.
			*
			* Returns the same jQuery object passed.
			**/
			animate: function() {
				return my.animate.apply(this, arguments);
			}
		};

		my = {
			items: [],
			index: 0,
			effects: {},
			elements: {},
			timers: {},
			interactive: false,
			swiping: false,

			enable: function() {
				var metrics, items, pagination;

				options = ob_set(options || {}, {
					'interactive': true,
					'base_zindex': 1,
					'id': null,
					'animation': {
						'automated': true,
						'type': WSCarousel.Animations.fade,
						'easing': 'swing',
						'delay': 5,
						'duration': 0.3,
						'finish': null, // callback
						'queue': 'wscarousel-queue'
					},
					'start': 0,
					'callbacks': {
						'pre_advance': null,
						'post_advance': null
					},
					'selectors': {
						'items': 'li'
					},
					'navigation': {
						'alignment': WSCarousel.Alignments.center
					},
					'pagination': {
						'alignment': WSCarousel.Alignments.center
					},
					'styles': {
						'container': {
							'position': 'relative'
						},
						'carousel': {
							'overflow': 'hidden',
							'position': 'relative',
							'margin': '0'
						}
					},
					'swipe': {
						'distance_trigger': 100,
						'time': 1000
					}
				});

				metrics = {
					'total_width': 0,
					'container_width': container.width()
				};

				if (!(container = $(container)).length) {
					throw new Error("Container element not specified.");
				} else {
					// increment queue number and add to animation queue label
					options.animation.queue += (window.WSCarousel.queueNum += 1);

					if (!options.styles.zIndex) {
						options.styles.zIndex = options.base_zindex;
					}

					container.css(
						options.styles.carousel
					);

					if (options.interactive) {
						container.addClass("carousel").bind("mouseenter", function() {
							my.interactive = true;
						}).bind("mouseleave", function() {
							my.interactive = false;
							my.timer();
						});
					}
				}

				//collect items, create pagination and navigation
				items = container.find(options.selectors.items);

				if (items.length === 0) {
					return false;
				} else {
					//create shim and insert around carousel
					my.elements.shim = $("<div>", {
						'class': 'carousel-container',
						'id': options.id
					}).css(options.styles.container);

					container.before(my.elements.shim);

					// set up shim
					my.elements.shim.append(container);

					// !create pagination
					if (items.length > 1 && options.pagination !== false) {
						pagination = [];

						my.elements.shim.append(
							my.elements.pagination = $("<ul>", {
								'class': 'pagination'
							}).css({
								'zIndex': items.length + (options.base_zindex + 10)
							}).on("click", "li.page", function(event) {
								var el;

								if ((el = $(this))) {
									event.preventDefault();
									my.select(el.data("index"));
								}
							})
						);
					}

					// !create navigation
					if (items.length > 1) {
						if (options.navigation !== false) {
							if (options.navigation === true ||
								(typeof options.navigation === "object" &&
									options.navigation.display !== false)) {
								my.elements.shim.append(
									my.elements.prev = $("<a>", {
										'href': '#',
										'class': 'navigation nav-prev'
									}).css({
										'zIndex': items.length + (options.base_zindex + 10)
									}).text("Prev").append(
										$("<span/>")
									)
								).append(
									my.elements.next = $("<a>", {
										'href': '#',
										'class': 'navigation nav-next'
									}).css({
										'zIndex': items.length + (options.base_zindex + 10)
									}).text("Next").append(
										$("<span/>")
									)
								);
							}

							if (options.navigation.swipe !== false) {
								my.elements.shim.bind(
									"touchstart touchmove touchend mousedown mousemove mouseup",
									my.event
								);
							}
						}

						my.elements.shim.on("click", "a.navigation", function(event) {
							event.preventDefault();

							switch (true) {
								case $(this).hasClass("nav-prev"):
									my.go(-1);
									break;

								default:
									my.go(1);
							}
						});
					}

					// gather items, calculate total width
					items.each(function(index) {
						var item, width, page_item, label, class_name;

						item = $(this);
						width = item.width();
						label = item.attr("title") || (index + 1);

						item.css({
							'position': 'absolute',
							'left': '0px',
							'width': '100%',
							'padding': 0,
							'margin': 0,
							'zIndex': ((items.length - index) + options.base_zindex)
						});

						if (index > 0) {
							item.css({
								'left': metrics.container_width + 'px',
								'opacity': 0
							});
						}

						if (options.pagination !== false && my.elements.pagination) {
							// !insert pagination entries
							class_name = 'page item-' + (index + 1);

							if (index === 0) {
								class_name += ' first';
							} else if (index === (items.length - 1)) {
								class_name += ' last';
							}

							my.elements.pagination.append(
								page_item = $("<li>", {
									'class': class_name
								}).append(
									$("<a>", {
										'href': '#'
									}).text(label).append(
										$("<span/>")
									)
								).data("index", index)
							);

							if (index === 0) {
								page_item.addClass("active");
							}

							pagination.push(page_item);
						}

						my.items.push(item);
					});

					// set pagination
					my.pagination = pagination;

					/**
					* WSCarousel#options -> Object
					*
					* The original options Object as passed to `WSCarousel`.
					**/
					cls.options = options;

					/**
					* WSCarousel#container -> Element
					*
					* The original container element as passed to `WSCarousel`.
					**/
					cls.container = container;

					/**
					* WSCarousel#elements -> Object
					*
					* An Object containing internal elements used for the carousel implementation
					* interface.
					**/
					cls.elements = my.elements;

					/**
					* WSCarousel#pagination -> Array
					*
					* An Array containing the individual pagination elements.
					**/
					cls.pagination = my.pagination;

					/**
					* WSCarousel#items -> Array
					*
					* An Array containing each indexed slide.
					**/
					cls.items = my.items;

					if (options.start < my.items.length && options.start >= 0) {
						my.adjust();
					}

					my.timer();
				}
			},

			adjust: function(effects) {
				// adjust the carousel after possible metric changes
				var nav_height, metrics;

				// return or perform on gathered metrics
				if (typeof effects === "object" && effects.constructor === Array) {
					// get metrics for next slide
					metrics = my.metrics(cls.animation.next);

					// add carousel resize effect (for all other effects)
					effects.push(
						my.animate(container, {
							'height': metrics.slide_height + 'px'
						})
					);

					if (metrics.pagination_left) {
						// add pagination resize effect
						effects.push(
							my.animate(my.elements.pagination, {
								'left': metrics.pagination_left + 'px'
							})
						);
					}

					if (metrics.nav_height_prev !== undefined && metrics.nav_height_next !== undefined) {
						// (re)align navigation
						effects.push(
							my.animate(my.elements.prev, {
								'top': metrics.nav_height_prev + 'px'
							})
						);

						effects.push(
							my.animate(my.elements.next, {
								'top': metrics.nav_height_next + 'px'
							})
						);
					}

					return effects;
				} else {
					// cancel existing effect
					if (my.effects.transition) {
						my.cancel();
					}

					// get metrics for current slide
					metrics = my.metrics(my.items[my.index]);

					container.css({
						'height': metrics.slide_height + 'px'
					});

					if (metrics.pagination_left) {
						// (re)align pagination
						my.elements.pagination.css({
							'left': metrics.pagination_left + 'px'
						});
					}

					if (metrics.nav_height_prev !== undefined && metrics.nav_height_next !== undefined) {
						// (re)align navigation
						my.elements.prev.css({
							'top': metrics.nav_height_prev + 'px'
						});

						my.elements.next.css({
							'top': metrics.nav_height_next + 'px'
						});
					}
				}
			},

			timer: function() {
				// start/reset the timer for automated motion
				if (options.animation.automated && !isNaN(options.animation.delay)) {
					if (my.timers.automation) {
						clearTimeout(my.timers.automation);
					}

					my.timers.automation = setTimeout(function() {
						if (!my.interactive) {
							my.go(1);
						}
					}, (options.animation.delay * 1000));
				}
			},

			event: function(event) {
				// global event handler
				var touch;

				if (event.type === "touchstart" || event.type === "touchmove") {
					touch = event.originalEvent.touches[0] ||
						event.originalEvent.changedTouches[0];
					event.pageX = touch.pageX;
					event.pageY = touch.pageY;
				}

				switch (event.type) {
					case "touchstart":
					case "mousedown":
						my.swiping = {
							'start': Date.now(),
							'origin': [event.pageX, event.pageY],
							'distance': [0, 0]
						};

						break;

					case "touchmove":
					case "mousemove":
						if (my.swiping !== false) {
							my.swiping.distance = [
								event.pageX - my.swiping.origin[0],
								event.pageY - my.swiping.origin[1]
							];

							return false;
						}

						break;

					case "touchend":
					case "mouseup":
						if ((Date.now() - my.swiping.start) <= options.swipe.time) {
							// swipe time within allowed timeframe
							event.preventDefault();

							if (my.swiping.distance[0] < (-options.swipe.distance_trigger)) {
								// left swipe
								my.go(1);
							} else if (my.swiping.distance[0] > options.swipe.distance_trigger) {
								// right swipe
								my.go(-1);
							}
						}

						my.swiping = false;
						break;
				}
			},

			go: function(adjustment) {
				// go x number of slides in negative or positive direction
				var index;

				index = my.index + adjustment;

				if (index < 0) {
					index = (my.items.length - 1);
				} else if (index > (my.items.length - 1)) {
					index = 0;
				}

				my.select(index, adjustment);
			},

			select: function(index, direction) {
				// animate to a certain slide item
				var finish, effects;

				if (index === my.index || my.animating) {
					return false;
				}

				if (direction === undefined) {
					direction = (index - my.index);
				}

				cls.animation = {
					'index': index,
					'direction': direction,
					'current': my.items[my.index],
					'next': my.items[index],
					'interactive': my.interactive
				};

				if (!options.callbacks.pre_advance ||
					(typeof options.callbacks.pre_advance === "function" &&
					(options.callbacks.pre_advance.apply(cls)))) {
					// ensure the animation object wasn't clobbered
					if (cls.animation === false || typeof cls.animation !== "object") {
						return false;
					}

					// add animation specific effects
					if ((effects = options.animation.type.apply(cls))) {
						if (typeof effects === "object" && effects.length) {
							// set mutex
							my.animating = true;

							// add carousel adjustments
							effects = $(my.adjust(effects));

							effects.each(function(index) {
								// run each effect
								this.dequeue(options.animation.queue);
							});
						}
					}
				} else {
					// start timer for next attempt
					my.timer();
				}
			},

			finish: function() {
				// switch nav
				if (my.items.length > 1 && options.pagination !== false && my.elements.pagination) {
					my.pagination[my.index].removeClass("active");
					my.pagination[cls.animation.index].addClass("active");
				}

				// set correct z-indexes
				cls.animation.next.css({
					'zIndex': cls.items.length + cls.options.base_zindex
				});

				cls.animation.current.css({
					'zIndex': (cls.items.length + cls.options.base_zindex) - 1
				});

				// execute optional finish callback
				if (typeof options.animation.finish === "function") {
					options.animation.finish.apply(cls);
				}

				// clean up
				delete my.effects.transition;

				my.index = cls.animation.index;
				my.animating = false;

				cls.animation.current = cls.animation.next;
				delete cls.animation.next;

				if ((typeof options.callbacks.post_advance === "function" &&
					(options.callbacks.post_advance.apply(cls))) ||
					(!options.callbacks.post_advance)) {
					// remove animation properties
					delete cls.animation;

					// start timer for next slide
					my.timer();
				}
			},

			cancel: function() {
				// cancel animation activity
				if (my.animating) {
					// animation is taking place
					my.animating = false;

					$(my.effects.transition).each(function() {
						this.stop();
					});

					delete my.effects.transition;

					// call animation with reset
					options.animation.type.apply(cls, [true]);

					delete cls.animation;

					my.adjust();
				}
			},

			metrics: function(slide) {
				var metrics;

				metrics = {
					'shim_width': my.elements.shim.width(),
					'container_width': container.width()
				};

				if (slide) {
					// get metrics for specified slide
					metrics.slide_height = slide.height();
				}

				if (options.navigation !== false) {
					// get metrics for navigation
					if (options.navigation === true) {
						// option is a basic setting - convert to object
						options.navigation = {
							'alignment': WSCarousel.Alignments.center
						};
					}

					switch (options.navigation.alignment) {
						case WSCarousel.Alignments.center:
							if (my.elements.prev && my.elements.prev.offsetParent) {
								metrics.nav_height_prev = ((metrics.slide_height / 2) - (my.elements.prev.height() / 2));
							}

							if (my.elements.next && my.elements.next.offsetParent) {
								metrics.nav_height_next = ((metrics.slide_height / 2) - (my.elements.next.height() / 2));
							}

							break;

						case WSCarousel.Alignments.top:
							if (my.elements.prev && my.elements.prev.offsetParent) {
								metrics.nav_height_prev = 0;
							}

							if (my.elements.next && my.elements.next.offsetParent) {
								metrics.nav_height_next = 0;
							}

							break;

						case WSCarousel.Alignments.bottom:
							if (my.elements.prev && my.elements.prev.offsetParent) {
								metrics.nav_height_prev = (metrics.slide_height - my.elements.prev.height());
							}

							if (my.elements.next && my.elements.next.offsetParent) {
								metrics.nav_height_next = (metrics.slide_height - my.elements.next.height());
							}
							break;
					}
				}

				if (options.pagination !== false && my.elements.pagination) {
					// get metrics for pagination
					if (options.pagination === true) {
						// option is a basic setting - convert to object
						options.pagination = {
							'alignment': WSCarousel.Alignments.center
						};
					}

					switch (options.pagination.alignment) {
						case WSCarousel.Alignments.left:
							metrics.pagination_left = 0;
							break;

						case WSCarousel.Alignments.right:
							metrics.pagination_left = metrics.shim_width - my.elements.pagination.width();
							break;

						case WSCarousel.Alignments.center:
							metrics.pagination_left = (metrics.shim_width / 2) - (my.elements.pagination.width() / 2);
					}
				}

				return metrics;
			},

			animate: function(elements, properties, opt) {
				opt = ob_set(opt || {}, {
					'duration': (options.animation.duration * 1000),
					'easing': cls.options.animation.easing
				});

				opt.queue = options.animation.queue;

				if (!my.effects.transition) {
					// first animation since cancellation or completion of last
					my.effects.transition = [];
					opt.done = my.finish;
				}

				if ((elements = $(elements)).length) {
					elements = elements.animate(properties, opt);
				}

				my.effects.transition.push(elements);

				return elements;
			}
		};

		my.enable();

		return cls;
	};

	// queue number (defaults to 0), incremented with each instance
	WSCarousel.queueNum = 0;

	/**
	* WSCarousel.Animations
	*
	* Animations are functions that are expected to return an array of effects
	* which act upon the slides, controlling their transition. The current avilable
	* built-in effects are:
	*
	* * `fade`: Will fade in a new slide on top of the old one.
	* * `slide`: Will move both slides horizontally, leaving the new slide in place.
	*
	* Each animation should pre-set the metrics for the slide to be animated and not
	* assume that a slide to be animated will be in the correct place before the transition
	* takes place.
	*
	* For the purposes of cancelling transitions, animation functions should sould also accept
	* a `reset` (`Boolean`) argument which will be passed when the carousel class is expecting
	* the function to only perform the re-setting actions without the need for returning an Array
	* of effects.
	*
	* If the `reset` argument is `false` or `undefined` then an Array of standard scriptaculous
	* effects is expected to be returned. The effects returned should be set for parallel use and
	* have their `sync` property set to `true`.
	*
	* The `animation` object contains relevant data for the purposes of providing
	* transition effects. See [[WSCarousel#animation]] for more information.
	**/
	WSCarousel.Animations = {
		// !WSCarousel.Animations
		fade: function(reset) {
			var effects;

			// set current slide on top, next slide underneath it
			this.animation.current.css({
				'zIndex': this.items.length + this.options.base_zindex,
				'opacity': 1
			});

			this.animation.next.css({
				'left': '0px',
				'zIndex': (this.items.length + this.options.base_zindex) - 1,
				'opacity': 0
			});

			if (!reset) {
				effects = [];

				effects.push(
					this.animate(this.animation.current, {
						'opacity': 0
					})
				);

				effects.push(
					this.animate(this.animation.next, {
						'opacity': 1
					})
				);

				return effects;
			}
		},

		slide: function(reset) {
			var effects;

			if (!reset) {
				effects = [];
			}

			this.animation.current.css({
				'left': '0',
				'opacity': 1
			});

			if (this.animation.direction > 0) {
				//right to left
				this.animation.next.css({
					'left': this.container.width() + 'px',
					'opacity': 0
				});

				if (!reset) {
					effects.push(
						this.animate(this.animation.current, {
							'left': -this.animation.current.width() + 'px'
						})
					);
				}
			} else {
				//left to right
				this.animation.next.css({
					'left': -this.animation.next.width() + 'px',
					'opacity': 0
				});

				if (!reset) {
					effects.push(
						this.animate(this.animation.current, {
							'left': this.animation.current.width() + 'px'
						})
					);
				}
			}

			if (!reset) {
				effects.push(
					this.animate(this.animation.current, {
						'opacity': 0
					})
				);

				effects.push(
					this.animate(this.animation.next, {
						'opacity': 1
					})
				);

				effects.push(
					this.animate(this.animation.next, {
						'left': '0px'
					}, {
						'queue': this.options.animation.queue
					})
				);

				return effects;
			}
		}
	};

	/**
	* WSCarousel.Alignments
	*
	* Mainly used for pagination and navigation, will dictate where within the container
	* the containing block(s) will align to. The following options are available:
	*
	* * `left`: Horizontal left alignment.
	* * `center`: Center alignment (depending on block width).
	* * `right`: Right alignment.
	* * `top`: Vertical top alignment.
	* * `bottom`: Vertical bottom alignment.
	*
	**/
	WSCarousel.Alignments = {
		// !WSCarousel.Alignments
		'left': 0,
		'center': 1,
		'right': 2,
		'top': 3,
		'bottom': 4
	};

	window.WSCarousel = WSCarousel;
}(window.jQuery, window.ob_set));